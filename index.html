<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Crusade Campaign Kit — Hex Map + Tokens + Rumors</title>
  <style>
    :root{
      --bg0:#07080b;
      --bg1:#0b0e14;

      --ink:#e9e6dc;
      --muted:#b7b1a2;
      --dim:#7d776b;

      --gold:#d1a14b;
      --red:#cc3b3b;
      --green:#3fbf7f;
      --blue:#4aa6ff;

      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.09);
      --stroke: rgba(255,255,255,0.14);

      --radius:18px;
      --shadow: 0 18px 50px rgba(0,0,0,0.45);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      color:var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(900px 600px at 20% 10%, rgba(74,166,255,0.14), transparent 55%),
        radial-gradient(800px 500px at 80% 30%, rgba(209,161,75,0.10), transparent 55%),
        radial-gradient(900px 700px at 50% 120%, rgba(63,191,127,0.10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 40%, var(--bg0));
      padding:14px;
    }

    .panel{
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .app{
      width:min(1680px, 100%);
      margin:0 auto;
      display:grid;
      grid-template-columns: 360px 1fr 420px;
      gap:12px;
      align-items:stretch;
    }
    @media (max-width: 1260px){
      .app{ grid-template-columns: 1fr; }
      .mapPanel svg{ height: min(70vh, 920px) !important; }
    }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .bigTitle{
      margin:0;
      font-size:14px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      font-weight:1000;
    }
    .sub{
      color:var(--muted);
      font-size:12px;
      line-height:1.35;
    }
    .title{
      font-size:12px;
      letter-spacing:0.16em;
      text-transform:uppercase;
      color:var(--muted);
      font-weight:900;
    }

    button{
      appearance:none;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color:var(--ink);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:750;
      letter-spacing:0.02em;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      font-size:12px;
      white-space:nowrap;
    }
    button:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.22);
    }
    button.primary{
      border-color: rgba(209,161,75,0.35);
      background: rgba(209,161,75,0.16);
    }
    button.primary:hover{
      background: rgba(209,161,75,0.22);
      border-color: rgba(209,161,75,0.50);
    }
    button:disabled{
      opacity:0.45;
      cursor:not-allowed;
      transform:none;
    }

    .section{ padding:12px 12px; border-top:1px solid rgba(255,255,255,0.10); }
    .section:first-child{ border-top:none; }
    .stack{ display:grid; gap:10px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .box{
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      border-radius: 14px;
      padding:10px 10px;
    }

    /* HUD */
    .hudHeader{
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,0.10);
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    label{
      color:var(--muted);
      font-size:11px;
      letter-spacing:0.10em;
      text-transform:uppercase;
      font-weight:800;
      display:block;
      margin-bottom:6px;
    }
    select{
      width:100%;
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.22);
      color: var(--ink);
      font-weight:800;
      outline:none;
    }
    select:focus{
      border-color: rgba(74,166,255,0.45);
      box-shadow: 0 0 0 2px rgba(74,166,255,0.12);
    }

    .moveBig{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
    }
    .moveBig .k{
      color:var(--muted);
      font-size:11px;
      letter-spacing:0.10em;
      text-transform:uppercase;
      font-weight:800;
    }
    .moveBig .v{
      font-size:22px;
      font-weight:1000;
      letter-spacing:0.02em;
    }
    .statusLine{
      color:var(--muted);
      font-size:12px;
      line-height:1.4;
    }
    .hintBar{
      border-top:1px solid rgba(255,255,255,0.10);
      padding:10px 12px;
      color:var(--muted);
      font-size:12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    /* Round board */
    .boardHeader{
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,0.10);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .chip{
      font-size:11px;
      letter-spacing:0.10em;
      text-transform:uppercase;
      padding:6px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      font-weight:900;
      white-space:nowrap;
    }
    .chip.blue{ border-color: rgba(74,166,255,0.35); color:#d8efff; }
    .chip.green{ border-color: rgba(63,191,127,0.35); color:#d9fff0; }
    .chip.red{ border-color: rgba(204,59,59,0.35); color:#ffd6d6; }
    .chip.gold{ border-color: rgba(209,161,75,0.40); color:#f2e6cf; }

    .list{ display:grid; gap:10px; }
    .item{
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      border-radius: 14px;
      padding:10px 10px;
    }
    .item.clickable{
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .item.clickable:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.22);
    }
    .itemTop{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .itemTitle{
      font-weight:1000;
      font-size:13px;
      line-height:1.25;
    }
    .itemSub{
      margin-top:6px;
      color:var(--muted);
      font-size:12px;
      line-height:1.45;
    }
    .smallDim{
      color:var(--dim);
      font-size:11px;
      margin-top:6px;
    }

    .starIcon{
      width:28px; height:28px;
      border-radius: 10px;
      display:grid;
      place-items:center;
      border:1px solid rgba(209,161,75,0.40);
      background: rgba(209,161,75,0.10);
      color: rgba(209,161,75,0.95);
      font-weight:1000;
      flex:0 0 auto;
    }
    .starRow{
      display:flex;
      gap:10px;
      align-items:flex-start;
    }

    /* Map */
    .mapHeader{
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,0.10);
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:flex-start;
    }
    .mapHeader .left{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width:0;
      flex: 1 1 auto;
    }
    .mapHeader .right{
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-end;
      flex: 0 0 auto;
    }

    .focusCard{
      max-width: 560px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      border-radius: 14px;
      padding:10px 10px;
    }
    .focusTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .focusTitle{
      font-weight:1000;
      font-size:12px;
      letter-spacing:0.10em;
      text-transform:uppercase;
      color: #f2e6cf;
    }
    .focusBody{
      margin-top:6px;
      color:var(--ink);
      font-size:12px;
      line-height:1.45;
    }
    .focusMeta{
      margin-top:6px;
      color:var(--muted);
      font-size:11px;
      line-height:1.4;
    }

    .mapWrap{ position:relative; padding:10px; }
    svg{
      width:100%;
      height:min(80vh, 980px);
      display:block;
      background: radial-gradient(700px 480px at 40% 30%, rgba(255,255,255,0.06), transparent 60%);
      border-radius: 14px;
      border:1px solid rgba(255,255,255,0.10);
      cursor: grab;
    }
    svg.dragging{ cursor: grabbing; }

    .toast{
      position:absolute;
      right:14px;
      bottom:14px;
      padding:10px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.52);
      color: var(--ink);
      font-size:12px;
      line-height:1.4;
      max-width: 640px;
      opacity:0;
      transform: translateY(6px);
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
      box-shadow: var(--shadow);
      white-space:pre-wrap;
    }
    .toast.show{ opacity:1; transform: translateY(0); }

    /* GM Drawer */
    .gmDock{ position:sticky; bottom:12px; margin-top:12px; }
    .gmDrawer{ width:min(1680px, 100%); margin:0 auto; }
    details.gm > summary{
      cursor:pointer;
      user-select:none;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color:var(--muted);
      font-weight:1000;
      letter-spacing:0.14em;
      text-transform:uppercase;
      font-size:11px;
      list-style:none;
    }
    details.gm > summary::-webkit-details-marker{ display:none; }
    .gmBody{
      border-top:1px solid rgba(255,255,255,0.10);
      padding:12px 14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .gmBody .left{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .gmBody .right{ color:var(--muted); font-size:12px; line-height:1.4; }
  </style>
</head>
<body>

  <div class="app">
    <!-- PLAYER HUD -->
    <div class="panel">
      <div class="hudHeader">
        <div class="bigTitle">Player HUD</div>
        <div class="sub">Pick your army token, roll movement, then click a highlighted hex.</div>
      </div>

      <div class="section">
        <div class="stack">
          <div>
            <label for="tokenSelect">Your Token</label>
            <select id="tokenSelect"></select>
            <div class="statusLine" id="tokenStatus">—</div>
          </div>

          <div class="moveBig">
            <div>
              <div class="k">Move Points</div>
              <div class="sub">d3 + team bonus (+ star bonuses where applicable)</div>
            </div>
            <div class="v mono" id="movePointsBig">—</div>
          </div>

          <div class="row">
            <button class="primary" id="btnRollMove" type="button">Roll Move</button>
            <button id="btnClearMove" type="button">Clear</button>
            <button id="btnFocus" type="button">Focus Me</button>
          </div>

          <div class="box">
            <div class="title">Base Movement Rules</div>
            <div class="sub" style="margin-top:6px;">
              <span class="mono">Imperium</span>: +1 move<br/>
              <span class="mono">Xenos</span>: minimum roll is 2<br/>
              <span class="mono">Chaos</span>: +1 effective move if destination is closer to nearest enemy
            </div>
          </div>

          <div class="box">
            <div class="title">Team Star Bonuses (STACKING)</div>
            <div class="sub" id="teamBonusesText" style="margin-top:6px;">
              —
/// </div>
          </div>

          <div class="box">
            <div class="title">What to do now</div>
            <div class="sub" id="playerHint" style="margin-top:6px;">
              Select a token to begin.
            </div>
          </div>
        </div>
      </div>

      <div class="hintBar">
        Tactical matchup locks at <span class="mono">range 2 + LOS</span>.
        Strategic rumor appears at <span class="mono">range 4</span>.
        Star sites stack: <span class="mono">3× VOX = 3 extra strategic rumors/round</span>.
      </div>
    </div>

    <!-- MAP -->
    <div class="panel mapPanel">
      <div class="mapHeader">
        <div class="left">
          <div class="bigTitle">Campaign Map</div>
          <div class="sub">Wheel zoom • Drag pan • Click token to select • Roll move then click highlighted hex • Click ★ list to jump</div>

          <div class="focusCard" id="focusCard" style="display:none;">
            <div class="focusTop">
              <div class="focusTitle" id="focusTitle">★ STAR SITE</div>
              <div class="chip gold" id="focusChip">STAR</div>
            </div>
            <div class="focusBody" id="focusBody">—</div>
            <div class="focusMeta mono" id="focusMeta">—</div>
          </div>
        </div>
        <div class="right">
          <div class="row">
            <button id="btnCenter" type="button">Center</button>
          </div>
        </div>
      </div>

      <div class="mapWrap">
        <svg id="svg" viewBox="0 0 1200 860" aria-label="Hex map"></svg>
        <div class="toast" id="toast"></div>
      </div>
    </div>

    <!-- ROUND BOARD -->
    <div class="panel">
      <div class="boardHeader">
        <div>
          <div class="bigTitle">Round Board</div>
          <div class="sub">Click any item to jump to its location on the map.</div>
        </div>
        <div class="chip gold" id="roundChip">Round 1</div>
      </div>

      <div class="section">
        <div class="title">Tactical Matchups</div>
        <div class="sub">Locked games (range 2 + LOS). Tokens are removed from pairing pool.</div>
        <div class="list" id="matchupList" style="margin-top:10px;"></div>
      </div>

      <div class="section">
        <div class="title">Strategic Rumors</div>
        <div class="sub">Pressure signals (range 4). These can be dodged by movement.</div>
        <div class="list" id="rumorList" style="margin-top:10px;"></div>
      </div>

      <div class="section">
        <div class="title">Star Sites Control</div>
        <div class="sub">Consistent types + stacking bonuses. Click a site to highlight and read.</div>
        <div class="list" id="starList" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>

  <!-- GM CONSOLE -->
  <div class="gmDock">
    <div class="panel gmDrawer">
      <details class="gm" id="gmDetails">
        <summary>
          <span>GM Console</span>
          <span class="sub">Reset • Randomize • Export • Round control</span>
        </summary>
        <div class="gmBody">
          <div class="left">
            <button class="primary" id="btnNewRound" type="button">New Round</button>
            <button id="btnRegenTerrain" type="button">Randomize Terrain</button>
            <button id="btnExport" type="button">Copy Round Export</button>
            <button id="btnResetMap" type="button">Reset Map</button>
          </div>
          <div class="right" id="gmStatus">
            Tip: Keep this closed during play. Players only need HUD + Board + Map.
          </div>
        </div>
      </details>
    </div>
  </div>

<script>
/* ===========================
   TEAMS + ARMIES (EXACT)
=========================== */
const TEAM = {
  IMPERIUM: "Imperium",
  XENOS: "Xenos",
  CHAOS: "Chaos"
};

const TOKEN_ROSTER = [
  { team: TEAM.IMPERIUM, name: "Grey Knights", short: "GK" },
  { team: TEAM.IMPERIUM, name: "Black Templar", short: "BT" },

  { team: TEAM.XENOS, name: "Tau", short: "TAU" },
  { team: TEAM.XENOS, name: "Tyranids", short: "NID" },
  { team: TEAM.XENOS, name: "Orks", short: "ORK" },

  { team: TEAM.CHAOS, name: "Death Guard", short: "DG" },
  { team: TEAM.CHAOS, name: "World Eaters", short: "WE" },
  { team: TEAM.CHAOS, name: "Emperor's Children", short: "EC" }
];

/* ===========================
   MAP SETTINGS
=========================== */
const HEX_SIZE = 34;
const GRID_RADIUS = 7;
const CENTER = { x: 600, y: 430 };

/* Terrain palette */
const BIOME_CHIP = {
  plains:   { dot:"rgba(255,255,255,0.55)", text:"rgba(255,255,255,0.80)" },
  forest:   { dot:"rgba(63,191,127,0.72)",  text:"rgba(63,191,127,0.94)"  },
  water:    { dot:"rgba(74,166,255,0.72)",  text:"rgba(74,166,255,0.94)"  },
  ruins:    { dot:"rgba(209,161,75,0.72)",  text:"rgba(209,161,75,0.94)"  },
  hive:     { dot:"rgba(255,255,255,0.70)", text:"rgba(255,255,255,0.92)" },
  ash:      { dot:"rgba(204,59,59,0.70)",   text:"rgba(204,59,59,0.92)"   },
  badlands: { dot:"rgba(209,161,75,0.62)",  text:"rgba(209,161,75,0.88)"  }
};

const BIOMES = [
  { id:"plains",   label:"PLAINS",  abbr:"PL" },
  { id:"forest",   label:"FOREST",  abbr:"FO" },
  { id:"water",    label:"WATER",   abbr:"WA" },
  { id:"ruins",    label:"RUINS",   abbr:"RU" },
  { id:"hive",     label:"HIVE",    abbr:"HV" },
  { id:"ash",      label:"ASH",     abbr:"AS" },
  { id:"badlands", label:"BADLAND", abbr:"BD" }
];

// Special hexes: LOS block and Movement block
const SPECIALS = [
  { id:"none",      label:"—",              blocks_los:false, blocks_movement:false, weight: 84 },
  { id:"blackout",  label:"Sensor Blackout",blocks_los:true,  blocks_movement:false, weight: 10 },
  { id:"exclusion", label:"Exclusion Zone", blocks_los:false, blocks_movement:true,  weight: 6  }
];

/* ===========================
   STAR SITES (CONSISTENT + STACKING)
=========================== */
const STAR_TYPES = [
  {
    id:"vox_relay",
    label:"Vox Relay",
    tag:"VOX",
    value:"Command & intel advantage",
    hook:"Grants +1 Strategic Rumor per round (range 4)."
  },
  {
    id:"shrine",
    label:"Shrine",
    tag:"SHR",
    value:"Morale & martyrdom site",
    hook:"Grants +1 'Pilgrimage Step' per round (free 1-hex move toward any controlled star site)."
  },
  {
    id:"manufactorum",
    label:"Manufactorum",
    tag:"MFG",
    value:"War material & repairs",
    hook:"Grants +1 Movement Reroll per round (d3 reroll, must take the new result)."
  },
  {
    id:"spaceport",
    label:"Spaceport",
    tag:"PORT",
    value:"Rapid deployment corridor",
    hook:"Grants +1 'Afterburn' per round (+1 move after rolling for a token)."
  },
  {
    id:"relic_site",
    label:"Relic Site",
    tag:"RELIC",
    value:"Archaeotech / sacred asset",
    hook:"Grants +1 'Relic Override' per round (treat LOS as clear through 1 blackout hex for a single tactical check)."
  },
  {
    id:"promethium",
    label:"Promethium Rig",
    tag:"FUEL",
    value:"Fuel & combustion supply",
    hook:"Grants +1 'Fuel Surge' per round (+1 movement for a token that ends on Plains/Badlands)."
  },
  {
    id:"data_vault",
    label:"Data Vault",
    tag:"DATA",
    value:"Targeting data / hidden records",
    hook:"Grants +1 'Reveal' per round (publicly reveal a chosen enemy token’s hex on the board)."
  }
];

function starDefById(id){ return STAR_TYPES.find(t=>t.id===id); }

// Balanced bag — more stars + even distribution
function buildStarBag(){
  const bag = [];
  const pushN = (id, n) => { for(let i=0;i<n;i++) bag.push(id); };

  // 17 total stars (dense enough to matter)
  pushN("vox_relay", 3);
  pushN("shrine", 3);
  pushN("manufactorum", 3);
  pushN("spaceport", 3);
  pushN("relic_site", 2);
  pushN("promethium", 2);
  pushN("data_vault", 1);

  // shuffle
  for(let i=bag.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [bag[i], bag[j]] = [bag[j], bag[i]];
  }
  return bag;
}

/* ===========================
   STATE
=========================== */
let hexes = new Map();
let tokens = [];
let round = 1;

let selectedTokenId = null;
let plannedDestKey = null;

let strategicRumors = [];
let tacticalMatchups = [];
let seenStrategicPairs = new Set();

// Movement highlight
let reachable = new Map();

// Star control
let starControl = new Map();

// Focus highlight/info
let focusedHexKey = null;
let focusPulseUntil = 0;

// Team bonus pool (STACKING)
let teamBonuses = {
  [TEAM.IMPERIUM]: initBonusCounters(),
  [TEAM.XENOS]: initBonusCounters(),
  [TEAM.CHAOS]: initBonusCounters()
};

function initBonusCounters(){
  return {
    vox: 0,
    shrine: 0,
    mfg: 0,
    port: 0,
    relic: 0,
    fuel: 0,
    data: 0
  };
}

/* ===========================
   DOM + HELPERS
=========================== */
const $ = (id) => document.getElementById(id);
const svg = $("svg");
const svgNS = "http://www.w3.org/2000/svg";

const keyOf = (q,r) => `${q},${r}`;
const parseKey = (k) => {
  const [q,r] = k.split(",").map(Number);
  return {q,r};
};

function toast(msg){
  const el = $("toast");
  el.textContent = msg;
  el.classList.add("show");
  clearTimeout(toast._t);
  toast._t = setTimeout(() => el.classList.remove("show"), 2400);
}

function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function weightedPick(items){
  const total = items.reduce((s,it)=>s+(it.weight||1),0);
  let r = Math.random()*total;
  for(const it of items){
    r -= (it.weight||1);
    if(r<=0) return it;
  }
  return items[items.length-1];
}
const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

/* ===========================
   HEX MATH
=========================== */
function axialDistance(aq,ar,bq,br){
  const ax=aq, az=ar, ay=-ax-az;
  const bx=bq, bz=br, by=-bx-bz;
  return Math.max(Math.abs(ax-bx), Math.abs(ay-by), Math.abs(az-bz));
}
function neighborsOf(q,r){
  const dirs = [
    {dq: 1, dr: 0}, {dq: 1, dr:-1}, {dq: 0, dr:-1},
    {dq:-1, dr: 0}, {dq:-1, dr: 1}, {dq: 0, dr: 1}
  ];
  return dirs.map(d => ({q:q+d.dq, r:r+d.dr}));
}
function axialToPixel(q,r){
  const x = HEX_SIZE * (Math.sqrt(3)*q + Math.sqrt(3)/2*r) + CENTER.x;
  const y = HEX_SIZE * (3/2*r) + CENTER.y;
  return {x,y};
}
function hexCorners(q,r){
  const c = axialToPixel(q,r);
  const pts = [];
  for(let i=0;i<6;i++){
    const ang = (Math.PI/180) * (60*i - 30);
    pts.push({ x: c.x + HEX_SIZE * Math.cos(ang), y: c.y + HEX_SIZE * Math.sin(ang) });
  }
  return pts;
}

/* LOS */
function axialToCube(q,r){ return {x:q, z:r, y:-q-r}; }
function cubeToAxial(c){ return {q:c.x, r:c.z}; }
function cubeLerp(a,b,t){ return { x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t, z:a.z+(b.z-a.z)*t }; }
function cubeRound(x,y,z){
  let rx=Math.round(x), ry=Math.round(y), rz=Math.round(z);
  const dx=Math.abs(rx-x), dy=Math.abs(ry-y), dz=Math.abs(rz-z);
  if(dx>dy && dx>dz) rx=-ry-rz;
  else if(dy>dz) ry=-rx-rz;
  else rz=-rx-ry;
  return {x:rx,y:ry,z:rz};
}
function hexLine(aq,ar,bq,br){
  const a=axialToCube(aq,ar), b=axialToCube(bq,br);
  const N=axialDistance(aq,ar,bq,br);
  const out=[];
  for(let i=0;i<=N;i++){
    const t = (N===0) ? 0 : (i/N);
    const p = cubeLerp(a,b,t);
    const r = cubeRound(p.x,p.y,p.z);
    out.push(cubeToAxial(r));
  }
  return out;
}
function hasLOS(aq,ar,bq,br, opts={}){
  // optional: allow one blackout to be ignored (Relic Override)
  const allowOneBlackout = !!opts.allowOneBlackout;
  let usedIgnore = false;

  const line = hexLine(aq,ar,bq,br);
  for(let i=1;i<line.length-1;i++){
    const k = keyOf(line[i].q, line[i].r);
    const sp = hexes.get(k)?.special;
    if(sp?.blocks_los){
      if(allowOneBlackout && !usedIgnore){
        usedIgnore = true;
        continue;
      }
      return false;
    }
  }
  return true;
}

/* ===========================
   TERRAIN + ★ GENERATION
=========================== */
function generateHexes(){
  hexes = new Map();

  for(let q=-GRID_RADIUS; q<=GRID_RADIUS; q++){
    for(let r=-GRID_RADIUS; r<=GRID_RADIUS; r++){
      if(axialDistance(0,0,q,r) > GRID_RADIUS) continue;
      const biome = pick(BIOMES);
      const special = weightedPick(SPECIALS);
      hexes.set(keyOf(q,r), { q,r, biome, special, important:null });
    }
  }

  // place stars using a balanced bag + spacing
  const keys = [...hexes.keys()];
  const bag = buildStarBag();
  const chosen = [];
  const minSpacing = 2;

  function isFarEnough(k){
    const a = parseKey(k);
    for(const ck of chosen){
      const b = parseKey(ck);
      if(axialDistance(a.q,a.r,b.q,b.r) < minSpacing) return false;
    }
    return true;
  }

  let attempts = 0;
  while(chosen.length < bag.length && attempts < 6000){
    attempts++;
    const k = keys[randInt(0, keys.length-1)];
    const h = hexes.get(k);
    if(!h) continue;
    if(h.special?.blocks_movement) continue;
    if(h.important) continue;
    if(!isFarEnough(k)) continue;
    chosen.push(k);
    h.important = { pending:true };
  }

  // Fill remainder if spacing prevented enough
  for(const k of keys){
    if(chosen.length >= bag.length) break;
    const h = hexes.get(k);
    if(!h || h.special?.blocks_movement || h.important) continue;
    chosen.push(k);
    h.important = { pending:true };
  }

  for(let i=0;i<chosen.length && i<bag.length;i++){
    const k = chosen[i];
    const h = hexes.get(k);
    const def = starDefById(bag[i]);
    h.important = {
      type: def.id,
      label: def.label,
      tag: def.tag,
      value: def.value,
      hook: def.hook
    };
  }

  starControl = new Map();
}

/* ===========================
   TOKENS + SPAWNS
=========================== */
function teamColor(team){
  if(team===TEAM.IMPERIUM) return { stroke:"rgba(74,166,255,0.62)", fill:"rgba(74,166,255,0.22)", chip:"blue" };
  if(team===TEAM.XENOS)    return { stroke:"rgba(63,191,127,0.62)", fill:"rgba(63,191,127,0.22)", chip:"green" };
  return { stroke:"rgba(204,59,59,0.62)", fill:"rgba(204,59,59,0.22)", chip:"red" };
}

function placeTokens(){
  tokens = TOKEN_ROSTER.map((t, idx) => ({
    id: `t${idx+1}`,
    team: t.team,
    faction: t.name,
    short: t.short,
    q: 0, r: 0,
    status: "available",
    movePoints: null,
    moveFrom: null
  }));

  // Three separated corners: (R,0), (-R,R), (0,-R)
  const starts = {
    [TEAM.IMPERIUM]: [
      { q: -GRID_RADIUS,     r:  GRID_RADIUS },
      { q: -GRID_RADIUS + 1, r:  GRID_RADIUS - 1 }
    ],
    [TEAM.XENOS]: [
      { q:  GRID_RADIUS,     r:  0 },
      { q:  GRID_RADIUS - 1, r:  0 },
      { q:  GRID_RADIUS - 1, r:  1 }
    ],
    [TEAM.CHAOS]: [
      { q:  0,               r: -GRID_RADIUS },
      { q:  1,               r: -GRID_RADIUS + 1 },
      { q:  0,               r: -GRID_RADIUS + 1 }
    ]
  };

  const byTeam = {
    [TEAM.IMPERIUM]: tokens.filter(t=>t.team===TEAM.IMPERIUM),
    [TEAM.XENOS]: tokens.filter(t=>t.team===TEAM.XENOS),
    [TEAM.CHAOS]: tokens.filter(t=>t.team===TEAM.CHAOS)
  };

  for(const team of Object.values(TEAM)){
    const arr = byTeam[team];
    const spots = starts[team] || [];
    arr.forEach((tok, i) => {
      const s = spots[i] || {q:0,r:0};
      let q=s.q, r=s.r;
      for(let tries=0; tries<12; tries++){
        const h = hexes.get(keyOf(q,r));
        if(h && !h.special.blocks_movement) break;
        // nudge
        q += randInt(-1,1);
        r += randInt(-1,1);
      }
      tok.q=q; tok.r=r;
    });
  }

  selectedTokenId = tokens[0]?.id || null;
  plannedDestKey = null;
  reachable = new Map();
}

/* ===========================
   STAR CONTROL + STACKING COUNTS
=========================== */
function computeStarControl(){
  starControl = new Map();

  for(const [k,h] of hexes.entries()){
    if(!h.important) continue;

    const occupants = tokens.filter(t => keyOf(t.q,t.r) === k);
    const teamsHere = [...new Set(occupants.map(o => o.team))];

    let owner = null;
    if(teamsHere.length === 1) owner = teamsHere[0];
    else if(teamsHere.length > 1) owner = "Contested";

    starControl.set(k, { owner, occupants });
  }
}

function computeTeamBonuses(){
  teamBonuses = {
    [TEAM.IMPERIUM]: initBonusCounters(),
    [TEAM.XENOS]: initBonusCounters(),
    [TEAM.CHAOS]: initBonusCounters()
  };

  for(const [k,h] of hexes.entries()){
    if(!h.important) continue;
    const owner = starControl.get(k)?.owner;
    if(!owner || owner === "Contested") continue;

    // STACKING: each site adds one count
    switch(h.important.type){
      case "vox_relay": teamBonuses[owner].vox++; break;
      case "shrine": teamBonuses[owner].shrine++; break;
      case "manufactorum": teamBonuses[owner].mfg++; break;
      case "spaceport": teamBonuses[owner].port++; break;
      case "relic_site": teamBonuses[owner].relic++; break;
      case "promethium": teamBonuses[owner].fuel++; break;
      case "data_vault": teamBonuses[owner].data++; break;
    }
  }
}

/* ===========================
   MOVEMENT
=========================== */
function d3(){ return Math.floor(Math.random()*3)+1; }
function getSelectedToken(){ return tokens.find(t=>t.id===selectedTokenId) || null; }

function nearestEnemyDistance(tokenId, q, r){
  const me = tokens.find(t=>t.id===tokenId);
  if(!me) return Infinity;
  let best = Infinity;
  for(const other of tokens){
    if(other.id===me.id) continue;
    if(other.status !== "available") continue;
    if(other.team === me.team) continue;
    best = Math.min(best, axialDistance(q,r, other.q, other.r));
  }
  return best;
}

function bfsReachable(startKey, maxDist){
  const start = parseKey(startKey);
  const dist = new Map();
  const q = [{ q:start.q, r:start.r }];

  dist.set(startKey, 0);

  while(q.length){
    const cur = q.shift();
    const curKey = keyOf(cur.q, cur.r);
    const curD = dist.get(curKey);

    for(const nb of neighborsOf(cur.q, cur.r)){
      const nk = keyOf(nb.q, nb.r);
      if(dist.has(nk)) continue;

      const h = hexes.get(nk);
      if(!h) continue;
      if(h.special?.blocks_movement) continue;

      const nd = curD + 1;
      if(nd > maxDist) continue;

      dist.set(nk, nd);
      q.push({ q:nb.q, r:nb.r });
    }
  }
  return dist;
}

function chaosEffectiveBonusActive(token, destKey){
  if(token.team !== TEAM.CHAOS) return false;
  if(token.movePoints == null || !token.moveFrom) return false;

  const start = parseKey(token.moveFrom);
  const dest = parseKey(destKey);

  const nearestStart = nearestEnemyDistance(token.id, start.q, start.r);
  const nearestDest  = nearestEnemyDistance(token.id, dest.q, dest.r);

  return Number.isFinite(nearestStart) && Number.isFinite(nearestDest) && nearestDest < nearestStart;
}

// Apply base team movement rules + (optionally) one PORT afterburn later via GM/house rule.
// We track available afterburn uses from PORT for the team (STACKING).
function rollMoveFor(token){
  if(!token) return;
  if(token.status !== "available"){ toast("This token is engaged (already matched)."); return; }

  computeStarControl();
  computeTeamBonuses();

  const roll = d3();
  let move = roll;

  if(token.team === TEAM.IMPERIUM) move = roll + 1;
  else if(token.team === TEAM.XENOS) move = Math.max(2, roll);

  token.movePoints = move;
  token.moveFrom = keyOf(token.q, token.r);
  plannedDestKey = null;

  computeReachableForSelected();

  toast(`Move rolled for ${token.faction}: d3=${roll} → Move=${move}`);
}

function computeReachableForSelected(){
  const tok = getSelectedToken();
  reachable = new Map();

  if(!tok || tok.movePoints == null || !tok.moveFrom) return;

  const startKey = keyOf(tok.q, tok.r);

  const base = bfsReachable(startKey, tok.movePoints);
  for(const [k,d] of base.entries()) reachable.set(k,d);

  // Chaos potential +1 reach (conditional)
  if(tok.team === TEAM.CHAOS){
    const bonus = bfsReachable(startKey, tok.movePoints + 1);
    for(const [k,d] of bonus.entries()){
      if(!reachable.has(k)) reachable.set(k,d);
    }
  }
}

/* ===========================
   RUMOR TEMPLATES
=========================== */
const STRATEGIC_TEMPLATES = [
  "Long-range augurs register hostile movement near {place}. Indicators suggest {theme}.",
  "Vox-traffic distortions cluster around {place}. Reports conflict, but point to {theme}.",
  "Civ rumor chains mention {place}. The pattern reads as {theme}. Expect misdirection."
];

const TACTICAL_TEMPLATES = [
  "Forward elements confirm enemy presence near {place}. Contact: {a} vs {b}.",
  "Auspex lock achieved at {place}. Matchup authorized: {a} against {b}.",
  "Confirmed sightings at {place}. {a} will clash with {b}."
];

const THEMES_BY_BIOME = {
  plains:   ["rapid maneuver", "flanking pressure", "breakthrough attempts", "counter-advances"],
  forest:   ["infiltration signs", "missing scouts", "ambush corridors", "concealed approach routes"],
  water:    ["crossing disruption", "isolated detachments", "supply delays", "stranded reinforcements"],
  ruins:    ["close-quarters sweeps", "hidden assets", "civilian unrest", "shadowed kill-zones"],
  hive:     ["crowded kill zones", "data-theft risk", "insurrection whispers", "sealed bulkheads shifting"],
  ash:      ["sensor noise", "toxic exposure", "auspex distortion", "lost bearings"],
  badlands: ["chokepoints", "raider lanes", "false trails", "line-of-advance traps"]
};

function normalizePair(aId,bId){ return [aId,bId].sort().join("|"); }

function bestContextPlace(a, b){
  // prefer star sites near either participant
  let best=null, bestScore=-1;

  for(const [k,h] of hexes.entries()){
    if(h.special?.blocks_movement) continue;
    const da = axialDistance(a.q,a.r, h.q,h.r);
    const db = axialDistance(b.q,b.r, h.q,h.r);
    if(Math.min(da,db) > 2) continue;

    let score = 0;
    if(h.important) score += 25; // bias star sites
    if(h.special?.blocks_los) score += 6;
    score += (2 - Math.min(da,db)) * 2;

    if(score > bestScore){ bestScore=score; best={k,h}; }
  }

  const chosen = best ? best : { k: keyOf(a.q,a.r), h: hexes.get(keyOf(a.q,a.r)) };

  const h = chosen.h;
  const parts = [];
  if(h?.important) parts.push(`★ ${h.important.label} (${h.important.tag})`);
  parts.push(h?.biome?.label || "Unknown Sector");
  if(h?.special?.id === "blackout") parts.push("JAMMED");
  if(h?.special?.id === "exclusion") parts.push("EXCLUSION");

  return { place: parts.join(" — "), biomeId: h?.biome?.id || "plains", key: chosen.k, site: h?.important || null };
}

function generateStrategicRumor(a, b){
  const ctx = bestContextPlace(a,b);
  const themePool = THEMES_BY_BIOME[ctx.biomeId] || THEMES_BY_BIOME.plains;
  const tpl = pick(STRATEGIC_TEMPLATES);
  const base = tpl.replace("{place}", ctx.place).replace("{theme}", pick(themePool));
  const extra = ctx.site ? ` Value at stake: ${ctx.site.value}.` : "";
  return { text: base + extra, locationKey: ctx.key };
}
function generateTacticalRumor(a, b){
  const ctx = bestContextPlace(a,b);
  const tpl = pick(TACTICAL_TEMPLATES);
  const base = tpl.replace("{place}", ctx.place).replace("{a}", a.faction).replace("{b}", b.faction);
  const extra = ctx.site ? ` Objective: ${ctx.site.value}.` : "";
  return { text: base + extra, locationKey: ctx.key };
}

/* ===========================
   RUMOR CHECKS (RANGE 4 + RANGE 2+LOS)
   - Tactical locks and removes both tokens from pool
   - Strategic: one per pair per round, range 4
   - IMPORTANT: we also grant extra strategic rumor allowances from VOX (STACKING)
     We handle this by allowing multiple strategic rumors per round overall; the generation
     still triggers on movement events, but VOX allows you to "force" extra strategic rumors
     from GM console in the future if you want. For now: VOX is shown and exported; strategic
     generation remains event-driven (so players see it as a consequence of movement).
=========================== */
function checkRumorsAfterMove(movedToken){
  if(!movedToken || movedToken.status !== "available") return;

  // Tactical: range 2 + LOS
  const candidatesTac = [];
  for(const other of tokens){
    if(other.id === movedToken.id) continue;
    if(other.status !== "available") continue;
    if(other.team === movedToken.team) continue;

    const d = axialDistance(movedToken.q, movedToken.r, other.q, other.r);
    if(d <= 2){
      const allowOneBlackout = false; // relic override could be used in future (spent resource)
      if(hasLOS(movedToken.q, movedToken.r, other.q, other.r, { allowOneBlackout })) {
        candidatesTac.push({ other, d });
      }
    }
  }
  candidatesTac.sort((a,b)=>a.d-b.d);

  if(candidatesTac.length){
    const enemy = candidatesTac[0].other;
    const r = generateTacticalRumor(movedToken, enemy);

    movedToken.status = "engaged";
    enemy.status = "engaged";

    tacticalMatchups.push({
      id: `M-${round}-${tacticalMatchups.length+1}`,
      aId: movedToken.id,
      bId: enemy.id,
      locationKey: r.locationKey,
      text: r.text
    });

    focusHex(r.locationKey, { reason:`Locked matchup: ${movedToken.short} vs ${enemy.short}`, openInfo:true });
    toast(`TACTICAL CONTACT: ${movedToken.faction} vs ${enemy.faction}`);
    return;
  }

  // Strategic: range 4
  const candidatesStrat = [];
  for(const other of tokens){
    if(other.id === movedToken.id) continue;
    if(other.status !== "available") continue;
    if(other.team === movedToken.team) continue;

    const d = axialDistance(movedToken.q, movedToken.r, other.q, other.r);
    if(d <= 4){
      const pairKey = normalizePair(movedToken.id, other.id);
      if(seenStrategicPairs.has(pairKey)) continue;
      candidatesStrat.push({ other, d, pairKey });
    }
  }
  candidatesStrat.sort((a,b)=>a.d-b.d);

  if(candidatesStrat.length){
    const c = candidatesStrat[0];
    seenStrategicPairs.add(c.pairKey);
    const r = generateStrategicRumor(movedToken, c.other);

    strategicRumors.push({
      id: `S-${round}-${strategicRumors.length+1}`,
      aId: movedToken.id,
      bId: c.other.id,
      locationKey: r.locationKey,
      text: r.text
    });

    toast(`Strategic pressure: ${movedToken.short} near ${c.other.short}`);
  }
}

/* ===========================
   FOCUS / HIGHLIGHT + INFO
=========================== */
function focusHex(hexKey, opts={}){
  const h = hexes.get(hexKey);
  if(!h) return;

  focusedHexKey = hexKey;
  focusPulseUntil = Date.now() + 2400;

  focusOnHex(hexKey);

  const openInfo = !!opts.openInfo;

  if(h.important || openInfo){
    const card = $("focusCard");
    card.style.display = "block";

    if(h.important){
      const ctl = starControl.get(hexKey)?.owner ?? null;
      const ownerText = ctl ? (ctl==="Contested" ? "Contested" : ctl) : "Unheld";

      $("focusTitle").textContent = `★ ${h.important.label} — ${h.important.tag}`;
      $("focusChip").textContent = ownerText;

      $("focusChip").className =
        (ctl==="Contested") ? "chip gold" :
        (ctl===TEAM.IMPERIUM) ? "chip blue" :
        (ctl===TEAM.XENOS) ? "chip green" :
        (ctl===TEAM.CHAOS) ? "chip red" : "chip";

      $("focusBody").textContent = `${h.important.value}. ${h.important.hook}`;

      const extra = [];
      extra.push(`Hex ${hexKey}`);
      extra.push(`${h.biome.label}`);
      if(h.special?.id === "blackout") extra.push("LOS: BLOCKED");
      if(h.special?.id === "exclusion") extra.push("MOVE: BLOCKED");
      $("focusMeta").textContent = extra.join(" • ");
    }else{
      $("focusTitle").textContent = `Map Focus`;
      $("focusChip").textContent = "INFO";
      $("focusChip").className = "chip";
      $("focusBody").textContent = opts.reason ? opts.reason : "Focused location.";
      $("focusMeta").textContent = `Hex ${hexKey}`;
    }
  }

  renderAll();
}

/* ===========================
   DRAW
=========================== */
function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

function biomeStyle(h){
  let fill = "rgba(255,255,255,0.05)";
  let stroke = "rgba(255,255,255,0.18)";

  switch(h.biome.id){
    case "forest":   fill="rgba(63,191,127,0.07)"; stroke="rgba(63,191,127,0.24)"; break;
    case "water":    fill="rgba(74,166,255,0.07)"; stroke="rgba(74,166,255,0.24)"; break;
    case "ruins":    fill="rgba(209,161,75,0.07)"; stroke="rgba(209,161,75,0.26)"; break;
    case "hive":     fill="rgba(255,255,255,0.06)"; stroke="rgba(255,255,255,0.26)"; break;
    case "ash":      fill="rgba(204,59,59,0.06)"; stroke="rgba(204,59,59,0.22)"; break;
    case "badlands": fill="rgba(209,161,75,0.05)"; stroke="rgba(209,161,75,0.22)"; break;
  }

  if(h.special?.id === "blackout"){ stroke="rgba(204,59,59,0.42)"; fill="rgba(0,0,0,0.34)"; }
  if(h.special?.id === "exclusion"){ stroke="rgba(204,59,59,0.50)"; fill="rgba(204,59,59,0.09)"; }

  return {fill, stroke};
}

function drawReachableOverlay(){
  if(!reachable || reachable.size === 0) return;
  const tok = getSelectedToken();
  if(!tok || tok.movePoints == null) return;

  const startKey = keyOf(tok.q,tok.r);

  for(const [k,d] of reachable.entries()){
    if(k === startKey) continue;
    const h = hexes.get(k);
    if(!h) continue;

    const pts = hexCorners(h.q,h.r).map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
    const poly = document.createElementNS(svgNS, "polygon");
    poly.setAttribute("points", pts);

    const chaosTint = (tok.team===TEAM.CHAOS && d > tok.movePoints);
    poly.setAttribute("fill", chaosTint ? "rgba(209,161,75,0.10)" : "rgba(74,166,255,0.08)");
    poly.setAttribute("stroke", chaosTint ? "rgba(209,161,75,0.36)" : "rgba(74,166,255,0.34)");
    poly.setAttribute("stroke-width", "2.0");
    poly.setAttribute("pointer-events", "none");

    svg.appendChild(poly);
  }
}

function drawHexes(){
  computeStarControl();
  computeTeamBonuses();

  for(const [k,h] of hexes.entries()){
    const pts = hexCorners(h.q,h.r).map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
    const st = biomeStyle(h);

    const poly = document.createElementNS(svgNS, "polygon");
    poly.setAttribute("points", pts);
    poly.setAttribute("fill", st.fill);
    poly.setAttribute("stroke", st.stroke);
    poly.setAttribute("stroke-width", "1.6");
    poly.setAttribute("data-hex", k);

    poly.addEventListener("click", (e) => { e.stopPropagation(); onHexClicked(k); });

    svg.appendChild(poly);

    const c = axialToPixel(h.q,h.r);

    // Terrain chip
    const chipStyle = BIOME_CHIP[h.biome.id] || BIOME_CHIP.plains;
    const chipX = c.x - 26;
    const chipY = c.y - 26;

    const chipBg = document.createElementNS(svgNS, "rect");
    chipBg.setAttribute("x", chipX);
    chipBg.setAttribute("y", chipY);
    chipBg.setAttribute("width", 50);
    chipBg.setAttribute("height", 16);
    chipBg.setAttribute("rx", 8);
    chipBg.setAttribute("fill", "rgba(0,0,0,0.34)");
    chipBg.setAttribute("stroke", "rgba(255,255,255,0.12)");
    chipBg.setAttribute("stroke-width", "1");
    chipBg.setAttribute("pointer-events", "none");
    svg.appendChild(chipBg);

    const dot = document.createElementNS(svgNS, "circle");
    dot.setAttribute("cx", chipX + 9);
    dot.setAttribute("cy", chipY + 8);
    dot.setAttribute("r", 3.2);
    dot.setAttribute("fill", chipStyle.dot);
    dot.setAttribute("pointer-events", "none");
    svg.appendChild(dot);

    const chipText = document.createElementNS(svgNS, "text");
    chipText.setAttribute("x", chipX + 16);
    chipText.setAttribute("y", chipY + 11.2);
    chipText.setAttribute("font-size", "9.5");
    chipText.setAttribute("fill", chipStyle.text);
    chipText.setAttribute("class", "mono");
    chipText.setAttribute("pointer-events", "none");
    chipText.textContent = h.biome.abbr;
    svg.appendChild(chipText);

    // Special markers
    if(h.special?.id === "blackout"){
      const t = document.createElementNS(svgNS, "text");
      t.setAttribute("x", c.x + 22);
      t.setAttribute("y", c.y + 12);
      t.setAttribute("text-anchor", "middle");
      t.setAttribute("font-size", "9.5");
      t.setAttribute("fill", "rgba(255,255,255,0.72)");
      t.setAttribute("class","mono");
      t.setAttribute("pointer-events","none");
      t.textContent = "JAM";
      svg.appendChild(t);
    }
    if(h.special?.id === "exclusion"){
      const t = document.createElementNS(svgNS, "text");
      t.setAttribute("x", c.x + 22);
      t.setAttribute("y", c.y + 12);
      t.setAttribute("text-anchor", "middle");
      t.setAttribute("font-size", "10.5");
      t.setAttribute("fill", "rgba(255,255,255,0.78)");
      t.setAttribute("class","mono");
      t.setAttribute("pointer-events","none");
      t.textContent = "X";
      svg.appendChild(t);
    }

    // ★ + tag + control ring
    if(h.important){
      const star = document.createElementNS(svgNS, "text");
      star.setAttribute("x", c.x);
      star.setAttribute("y", c.y - 12);
      star.setAttribute("text-anchor", "middle");
      star.setAttribute("font-size", "12");
      star.setAttribute("fill", "rgba(209,161,75,0.90)");
      star.setAttribute("pointer-events","none");
      star.textContent = "★";
      svg.appendChild(star);

      const tag = document.createElementNS(svgNS, "text");
      tag.setAttribute("x", c.x);
      tag.setAttribute("y", c.y - 2);
      tag.setAttribute("text-anchor", "middle");
      tag.setAttribute("font-size", "9.5");
      tag.setAttribute("fill", "rgba(209,161,75,0.85)");
      tag.setAttribute("class", "mono");
      tag.setAttribute("pointer-events","none");
      tag.textContent = h.important.tag;
      svg.appendChild(tag);

      const ctl = starControl.get(k)?.owner ?? null;
      if(ctl){
        const ring = document.createElementNS(svgNS, "circle");
        ring.setAttribute("cx", c.x);
        ring.setAttribute("cy", c.y);
        ring.setAttribute("r", "22");
        if(ctl === "Contested"){
          ring.setAttribute("stroke", "rgba(209,161,75,0.55)");
          ring.setAttribute("stroke-dasharray", "4 3");
        }else{
          const col = teamColor(ctl);
          ring.setAttribute("stroke", col.stroke);
        }
        ring.setAttribute("fill", "transparent");
        ring.setAttribute("stroke-width", "2.0");
        ring.setAttribute("pointer-events","none");
        svg.appendChild(ring);
      }
    }
  }
}

function drawTokens(){
  for(const tok of tokens){
    const c = axialToPixel(tok.q, tok.r);
    const g = document.createElementNS(svgNS, "g");
    g.setAttribute("data-token", tok.id);
    g.setAttribute("cursor", "pointer");

    const col = teamColor(tok.team);

    const ring = document.createElementNS(svgNS, "circle");
    ring.setAttribute("cx", c.x);
    ring.setAttribute("cy", c.y);
    ring.setAttribute("r", "16");
    ring.setAttribute("fill", col.fill);
    ring.setAttribute("stroke", col.stroke);
    ring.setAttribute("stroke-width", tok.id===selectedTokenId ? "3.2" : "2.2");
    if(tok.status === "engaged"){
      ring.setAttribute("stroke-dasharray", "3 3");
      ring.setAttribute("fill", "rgba(255,255,255,0.03)");
    }
    g.appendChild(ring);

    const t = document.createElementNS(svgNS, "text");
    t.setAttribute("x", c.x);
    t.setAttribute("y", c.y + 4);
    t.setAttribute("text-anchor", "middle");
    t.setAttribute("font-size", "10.5");
    t.setAttribute("fill", "rgba(255,255,255,0.86)");
    t.setAttribute("class","mono");
    t.textContent = tok.short;
    g.appendChild(t);

    g.addEventListener("click", (e) => { e.stopPropagation(); selectToken(tok.id); });
    svg.appendChild(g);
  }
}

function drawSelection(){
  const tok = getSelectedToken();
  if(tok){
    const k = keyOf(tok.q,tok.r);
    const h = hexes.get(k);
    if(h){
      const pts = hexCorners(h.q,h.r).map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
      const poly = document.createElementNS(svgNS, "polygon");
      poly.setAttribute("points", pts);
      poly.setAttribute("fill", "transparent");
      poly.setAttribute("stroke", "rgba(255,255,255,0.65)");
      poly.setAttribute("stroke-width", "2.4");
      poly.setAttribute("pointer-events", "none");
      svg.appendChild(poly);
    }
  }

  if(plannedDestKey){
    const d = hexes.get(plannedDestKey);
    if(d){
      const pts = hexCorners(d.q,d.r).map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
      const poly = document.createElementNS(svgNS, "polygon");
      poly.setAttribute("points", pts);
      poly.setAttribute("fill", "rgba(74,166,255,0.10)");
      poly.setAttribute("stroke", "rgba(74,166,255,0.55)");
      poly.setAttribute("stroke-width", "2.6");
      poly.setAttribute("pointer-events", "none");
      svg.appendChild(poly);
    }
  }

  // focused hex ring + pulse
  if(focusedHexKey){
    const h = hexes.get(focusedHexKey);
    if(h){
      const pts = hexCorners(h.q,h.r);
      const c = axialToPixel(h.q,h.r);

      const poly = document.createElementNS(svgNS, "polygon");
      poly.setAttribute("points", pts.map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" "));
      poly.setAttribute("fill", "rgba(209,161,75,0.08)");
      poly.setAttribute("stroke", "rgba(209,161,75,0.92)");
      poly.setAttribute("stroke-width", "3.0");
      poly.setAttribute("pointer-events", "none");
      svg.appendChild(poly);

      const now = Date.now();
      if(now < focusPulseUntil){
        const t = (focusPulseUntil - now) / 2400; // 1..0
        const r = 6 + (1-t)*16;

        const pulse = document.createElementNS(svgNS, "circle");
        pulse.setAttribute("cx", c.x);
        pulse.setAttribute("cy", c.y);
        pulse.setAttribute("r", String(r));
        pulse.setAttribute("fill", "rgba(209,161,75,0.12)");
        pulse.setAttribute("stroke", "rgba(209,161,75,0.55)");
        pulse.setAttribute("stroke-width", "2");
        pulse.setAttribute("pointer-events", "none");
        svg.appendChild(pulse);

        requestAnimationFrame(() => renderAll());
      }
    }
  }
}

function renderMap(){
  clearSVG();
  drawHexes();
  drawReachableOverlay();
  drawTokens();
  drawSelection();
}

/* ===========================
   PLAYER HUD RENDER
=========================== */
function renderTokenSelect(){
  const sel = $("tokenSelect");
  sel.innerHTML = "";

  for(const tok of tokens){
    const opt = document.createElement("option");
    opt.value = tok.id;
    opt.textContent = `${tok.faction} (${tok.team}) — ${tok.short}`;
    sel.appendChild(opt);
  }
  sel.value = selectedTokenId || tokens[0]?.id || "";
}

function renderPlayerHUD(){
  computeStarControl();
  computeTeamBonuses();

  const tok = getSelectedToken();
  if(!tok){
    $("tokenStatus").textContent = "—";
    $("movePointsBig").textContent = "—";
    $("playerHint").textContent = "Select a token to begin.";
    $("btnRollMove").disabled = true;
    $("btnClearMove").disabled = true;
    return;
  }

  const onHex = keyOf(tok.q,tok.r);
  const engaged = tok.status !== "available";

  $("tokenStatus").textContent =
    `${tok.team} • ${tok.short} @ ${onHex} • ` + (engaged ? "ENGAGED (matched)" : "READY");

  $("movePointsBig").textContent = (tok.movePoints == null ? "—" : String(tok.movePoints));

  if(engaged){
    $("playerHint").textContent = "This token is engaged this round. Watch Round Board for matchups.";
  }else if(tok.movePoints == null){
    $("playerHint").textContent = "Roll movement, then click any highlighted hex to move.";
  }else{
    if(tok.team === TEAM.CHAOS){
      $("playerHint").textContent = "Click a highlighted hex. Gold reach is conditional (+1 only if you move closer to nearest enemy).";
    }else{
      $("playerHint").textContent = "Click a highlighted hex to move. Tactical contact locks at range 2 + LOS.";
    }
  }

  $("btnRollMove").disabled = engaged;
  $("btnClearMove").disabled = false;

  // Show stacking bonuses for selected token’s team
  const b = teamBonuses[tok.team];
  $("teamBonusesText").textContent =
    `VOX: +${b.vox} strategic rumors/round
SHR: +${b.shrine} pilgrimage steps/round
MFG: +${b.mfg} movement rerolls/round
PORT: +${b.port} afterburns/round
RELIC: +${b.relic} relic overrides/round
FUEL: +${b.fuel} fuel surges/round
DATA: +${b.data} reveals/round`;
}

/* ===========================
   ROUND BOARD RENDER
=========================== */
function renderMatchups(){
  const el = $("matchupList");
  el.innerHTML = "";

  if(!tacticalMatchups.length){
    const empty = document.createElement("div");
    empty.className = "box";
    empty.innerHTML = `<div class="sub">No locked games yet.</div>`;
    el.appendChild(empty);
    return;
  }

  for(const m of tacticalMatchups){
    const a = tokens.find(t=>t.id===m.aId);
    const b = tokens.find(t=>t.id===m.bId);
    const loc = hexes.get(m.locationKey);
    const place = loc?.important ? `★ ${loc.important.label} (${loc.important.tag})` : (loc?.biome?.label || "Unknown");

    const card = document.createElement("div");
    card.className = "item clickable";
    card.title = "Click to focus this location on the map";
    card.addEventListener("click", () => focusHex(m.locationKey, { reason:m.text, openInfo:true }));

    card.innerHTML = `
      <div class="itemTop">
        <div class="itemTitle">${a?.faction || "?"} vs ${b?.faction || "?"}</div>
        <div class="chip gold">${m.id}</div>
      </div>
      <div class="itemSub">${m.text}</div>
      <div class="smallDim mono">Location: ${place} • Hex ${m.locationKey}</div>
    `;
    el.appendChild(card);
  }
}

function renderRumors(){
  const el = $("rumorList");
  el.innerHTML = "";

  if(!strategicRumors.length){
    const empty = document.createElement("div");
    empty.className = "box";
    empty.innerHTML = `<div class="sub">No strategic pressure signals yet.</div>`;
    el.appendChild(empty);
    return;
  }

  for(const r of strategicRumors.slice(-8).reverse()){
    const a = tokens.find(t=>t.id===r.aId);
    const b = tokens.find(t=>t.id===r.bId);
    const loc = hexes.get(r.locationKey);
    const place = loc?.important ? `★ ${loc.important.label} (${loc.important.tag})` : (loc?.biome?.label || "Unknown");

    const card = document.createElement("div");
    card.className = "item clickable";
    card.title = "Click to focus this location on the map";
    card.addEventListener("click", () => focusHex(r.locationKey, { reason:r.text, openInfo:true }));

    card.innerHTML = `
      <div class="itemTop">
        <div class="itemTitle">${a?.short || "?"} ↔ ${b?.short || "?"}</div>
        <div class="chip">${r.id}</div>
      </div>
      <div class="itemSub">${r.text}</div>
      <div class="smallDim mono">Near: ${place} • Hex ${r.locationKey}</div>
    `;
    el.appendChild(card);
  }
}

function renderStars(){
  computeStarControl();
  computeTeamBonuses();

  const el = $("starList");
  el.innerHTML = "";

  const stars = [...hexes.entries()]
    .filter(([k,h]) => h.important)
    .map(([k,h]) => ({ key:k, hex:h, ctl: starControl.get(k) }))
    .sort((a,b) => {
      const oa = a.hex.important.tag, ob = b.hex.important.tag;
      if(oa < ob) return -1;
      if(oa > ob) return 1;
      return a.key.localeCompare(b.key);
    });

  if(!stars.length){
    const empty = document.createElement("div");
    empty.className = "box";
    empty.innerHTML = `<div class="sub">No star sites found (reroll terrain).</div>`;
    el.appendChild(empty);
    return;
  }

  for(const s of stars){
    const owner = s.ctl?.owner ?? null;

    let chipClass = "chip";
    let chipText = "Unheld";
    if(owner === "Contested"){ chipClass = "chip gold"; chipText="Contested"; }
    else if(owner === TEAM.IMPERIUM){ chipClass="chip blue"; chipText="Imperium"; }
    else if(owner === TEAM.XENOS){ chipClass="chip green"; chipText="Xenos"; }
    else if(owner === TEAM.CHAOS){ chipClass="chip red"; chipText="Chaos"; }

    const occ = (s.ctl?.occupants || []).map(o => o.short).join(", ");

    const card = document.createElement("div");
    card.className = "item clickable";
    card.title = "Click to jump to this star site";
    card.addEventListener("click", () => focusHex(s.key, { openInfo:true }));

    card.innerHTML = `
      <div class="starRow">
        <div class="starIcon">★</div>
        <div style="flex:1 1 auto; min-width:0;">
          <div class="itemTop">
            <div class="itemTitle">${s.hex.important.label} <span class="mono">(${s.hex.important.tag})</span></div>
            <div class="${chipClass}">${chipText}</div>
          </div>
          <div class="itemSub">${s.hex.important.value} — ${s.hex.important.hook}</div>
          <div class="smallDim mono">Hex ${s.key} • Occupants: ${occ || "—"}</div>
        </div>
      </div>
    `;
    el.appendChild(card);
  }
}

function renderRoundChip(){
  $("roundChip").textContent = `Round ${round}`;
}

/* ===========================
   CORE INTERACTION
=========================== */
function selectToken(id){
  selectedTokenId = id;
  plannedDestKey = null;
  computeReachableForSelected();
  renderAll();
}

function onHexClicked(hexKey){
  const tok = getSelectedToken();
  if(!tok) return;

  plannedDestKey = hexKey;

  if(tok.status !== "available"){
    toast("This token is engaged this round.");
    renderAll();
    return;
  }

  const h = hexes.get(hexKey);

  if(tok.movePoints == null || !tok.moveFrom){
    if(h?.important) focusHex(hexKey, { openInfo:true });
    else toast("Roll movement first, then click a highlighted hex.");
    renderAll();
    return;
  }

  if(!reachable.has(hexKey)){
    if(h?.important) focusHex(hexKey, { openInfo:true });
    else toast("Not reachable (must be highlighted).");
    renderAll();
    return;
  }

  const dist = reachable.get(hexKey);
  if(tok.team === TEAM.CHAOS && dist > tok.movePoints){
    if(!chaosEffectiveBonusActive(tok, hexKey)){
      toast("Chaos +1 not active (destination must be closer to nearest enemy). Pick another hex.");
      renderAll();
      return;
    }
  }

  const dest = parseKey(hexKey);
  tok.q = dest.q;
  tok.r = dest.r;

  tok.movePoints = null;
  tok.moveFrom = null;
  reachable = new Map();
  plannedDestKey = null;

  // Auto-focus stars
  if(h?.important) focusHex(hexKey, { openInfo:true });

  checkRumorsAfterMove(tok);
  renderAll();
}

/* ===========================
   BUTTONS
=========================== */
$("tokenSelect").addEventListener("change", (e) => selectToken(e.target.value));

$("btnRollMove").addEventListener("click", () => {
  const tok = getSelectedToken();
  if(!tok) return;
  rollMoveFor(tok);
  renderAll();
});

$("btnClearMove").addEventListener("click", () => {
  const tok = getSelectedToken();
  if(!tok) return;
  tok.movePoints = null;
  tok.moveFrom = null;
  reachable = new Map();
  plannedDestKey = null;
  toast("Move cleared.");
  renderAll();
});

$("btnFocus").addEventListener("click", () => {
  const tok = getSelectedToken();
  if(!tok) return;
  focusOnHex(keyOf(tok.q,tok.r));
  toast("Focused on your token.");
});

$("btnCenter").addEventListener("click", () => {
  resetView();
  toast("View centered.");
});

$("btnNewRound").addEventListener("click", () => {
  round += 1;
  strategicRumors = [];
  tacticalMatchups = [];
  seenStrategicPairs = new Set();

  for(const t of tokens){
    t.status = "available";
    t.movePoints = null;
    t.moveFrom = null;
  }
  reachable = new Map();
  plannedDestKey = null;

  toast(`New round started: Round ${round}`);
  renderAll();
});

$("btnRegenTerrain").addEventListener("click", () => {
  generateHexes();

  // nudge tokens off blocked movement tiles if needed
  for(const tok of tokens){
    const h = hexes.get(keyOf(tok.q,tok.r));
    if(h?.special?.blocks_movement){
      const nbs = neighborsOf(tok.q,tok.r);
      let moved=false;
      for(const nb of nbs){
        const nh = hexes.get(keyOf(nb.q,nb.r));
        if(nh && !nh.special.blocks_movement){
          tok.q=nb.q; tok.r=nb.r; moved=true; break;
        }
      }
      if(!moved){ tok.q=0; tok.r=0; }
    }
  }

  computeReachableForSelected();
  toast("Terrain randomized (tokens preserved).");
  renderAll();
});

$("btnResetMap").addEventListener("click", () => {
  round = 1;
  strategicRumors = [];
  tacticalMatchups = [];
  seenStrategicPairs = new Set();

  generateHexes();
  placeTokens();

  resetView();
  toast("Map and round state reset.");
  renderAll();
});

$("btnExport").addEventListener("click", async () => {
  computeStarControl();
  computeTeamBonuses();

  const exportObj = {
    round,
    map: { gridRadius: GRID_RADIUS },
    tokens: tokens.map(t=>({ id:t.id, team:t.team, faction:t.faction, short:t.short, q:t.q, r:t.r, status:t.status })),
    starSites: [...hexes.entries()]
      .filter(([k,h]) => h.important)
      .map(([k,h]) => ({ key:k, type:h.important.type, tag:h.important.tag, label:h.important.label, value:h.important.value, hook:h.important.hook })),
    starControl: [...starControl.entries()].map(([k,v]) => ({ key:k, owner:v.owner, occupants:(v.occupants||[]).map(o=>o.short) })),
    teamBonuses, // STACKING counts
    strategicRumors,
    tacticalMatchups
  };

  const text = JSON.stringify(exportObj, null, 2);
  try{
    await navigator.clipboard.writeText(text);
    toast("Round export copied (JSON).");
  }catch(e){
    console.log(text);
    toast("Clipboard blocked — export printed to console.");
  }
});

/* ===========================
   VIEWBOX ZOOM + PAN
=========================== */
let vb = { x:0, y:0, w:1200, h:860 };
function applyViewBox(){ svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.w} ${vb.h}`); }
function resetView(){ vb = { x:0, y:0, w:1200, h:860 }; applyViewBox(); }

function svgPointFromClient(clientX, clientY){
  const rect = svg.getBoundingClientRect();
  const px = (clientX - rect.left) / rect.width;
  const py = (clientY - rect.top) / rect.height;
  return { x: vb.x + px*vb.w, y: vb.y + py*vb.h };
}

let isDragging=false, dragStart=null, vbStart=null;

svg.addEventListener("mousedown", (e) => {
  isDragging = true;
  svg.classList.add("dragging");
  dragStart = svgPointFromClient(e.clientX, e.clientY);
  vbStart = { ...vb };
});
window.addEventListener("mousemove", (e) => {
  if(!isDragging) return;
  const cur = svgPointFromClient(e.clientX, e.clientY);
  const dx = cur.x - dragStart.x;
  const dy = cur.y - dragStart.y;
  vb.x = vbStart.x - dx;
  vb.y = vbStart.y - dy;
  applyViewBox();
});
window.addEventListener("mouseup", () => {
  if(!isDragging) return;
  isDragging = false;
  svg.classList.remove("dragging");
});
svg.addEventListener("wheel", (e) => {
  e.preventDefault();

  const zoomIntensity = 0.12;
  const delta = Math.sign(e.deltaY);
  const factor = 1 + (delta * zoomIntensity);

  const mouse = svgPointFromClient(e.clientX, e.clientY);

  const newW = vb.w * factor;
  const newH = vb.h * factor;

  const minW = 420;
  const maxW = 2400;
  if(newW < minW || newW > maxW) return;

  const rx = (mouse.x - vb.x) / vb.w;
  const ry = (mouse.y - vb.y) / vb.h;

  vb.x = mouse.x - rx * newW;
  vb.y = mouse.y - ry * newH;
  vb.w = newW;
  vb.h = newH;

  applyViewBox();
}, { passive:false });

function focusOnHex(hexKey){
  const h = hexes.get(hexKey);
  if(!h) return;
  const c = axialToPixel(h.q,h.r);
  vb.x = c.x - vb.w/2;
  vb.y = c.y - vb.h/2;
  applyViewBox();
}

/* ===========================
   INIT + RENDER
=========================== */
function renderAll(){
  computeStarControl();
  computeTeamBonuses();

  renderRoundChip();
  renderTokenSelect();
  renderPlayerHUD();
  renderMatchups();
  renderRumors();
  renderStars();
  renderMap();
}

function init(){
  generateHexes();
  placeTokens();
  resetView();
  computeReachableForSelected();
  renderAll();
  toast("Star Sites are consistent + stacking. Click ★ list to jump & read bonuses.");
}
init();
</script>
</body>
</html>
