<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Crusade Campaign Kit — Map + Movement + Rumors</title>
  <style>
    :root{
      --bg0:#07080b;
      --bg1:#0b0e14;
      --ink:#e9e6dc;
      --muted:#b7b1a2;
      --dim:#7d776b;

      --gold:#d1a14b;
      --red:#cc3b3b;
      --green:#3fbf7f;
      --blue:#4aa6ff;

      --panel: rgba(255,255,255,0.06);
      --stroke: rgba(255,255,255,0.14);

      --radius:18px;
      --shadow: 0 18px 50px rgba(0,0,0,0.45);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      color:var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(900px 600px at 20% 10%, rgba(74,166,255,0.14), transparent 55%),
        radial-gradient(800px 500px at 80% 30%, rgba(209,161,75,0.10), transparent 55%),
        radial-gradient(900px 700px at 50% 120%, rgba(63,191,127,0.10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 40%, var(--bg0));
      padding:18px;
    }

    .app{
      width:min(1420px, 100%);
      margin:0 auto;
      display:grid;
      grid-template-columns: 400px 1fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 1160px){
      .app{ grid-template-columns: 1fr; }
    }

    .panel{
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .p-head{
      padding:14px 16px;
      border-bottom:1px solid var(--stroke);
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }
    .p-head h1{
      margin:0;
      font-size:14px;
      letter-spacing:0.16em;
      text-transform:uppercase;
    }
    .p-sub{
      margin-top:6px;
      color:var(--muted);
      font-size:12px;
      line-height:1.45;
    }

    .btnrow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      justify-content:flex-end;
    }
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color:var(--ink);
      padding:8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:650;
      letter-spacing:0.02em;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      font-size:12px;
      white-space:nowrap;
    }
    button:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.22);
    }
    button.primary{
      border-color: rgba(209,161,75,0.35);
      background: rgba(209,161,75,0.16);
    }
    button.primary:hover{
      background: rgba(209,161,75,0.22);
      border-color: rgba(209,161,75,0.50);
    }
    button.danger{
      border-color: rgba(204,59,59,0.35);
      background: rgba(204,59,59,0.14);
    }
    button.danger:hover{
      background: rgba(204,59,59,0.20);
      border-color: rgba(204,59,59,0.50);
    }
    button:disabled{
      opacity:0.45;
      cursor:not-allowed;
      transform:none;
    }

    .p-body{ padding:14px 16px; }

    .section{
      margin-top:12px;
      border-top:1px solid var(--stroke);
      padding-top:12px;
    }
    .section:first-child{
      margin-top:0;
      border-top:none;
      padding-top:0;
    }
    .section h2{
      margin:0 0 8px 0;
      font-size:12px;
      letter-spacing:0.14em;
      text-transform:uppercase;
      color:var(--muted);
    }

    .kv{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
    }
    .pill{
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      border-radius: 14px;
      padding:8px 10px;
      min-height: 54px;
    }
    .k{
      font-size:11px;
      letter-spacing:0.10em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .v{
      margin-top:6px;
      font-weight:800;
      font-size:13px;
      line-height:1.25;
    }

    .list{ display:grid; gap:8px; }

    .tokenCard{
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      border-radius: 14px;
      padding:10px 10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      cursor:pointer;
      transition: border-color .12s ease, background .12s ease;
    }
    .tokenCard:hover{
      border-color: rgba(255,255,255,0.22);
      background: rgba(255,255,255,0.06);
    }
    .tokenCard.active{
      border-color: rgba(74,166,255,0.45);
      box-shadow: 0 0 0 2px rgba(74,166,255,0.14) inset;
    }
    .tokenMeta{
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width: 0;
    }
    .tokenName{
      font-weight:900;
      font-size:13px;
      line-height:1.2;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .tokenSub{
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .badge{
      font-size:11px;
      letter-spacing:0.10em;
      text-transform:uppercase;
      padding:6px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      flex:0 0 auto;
    }
    .badge.blue{ border-color: rgba(74,166,255,0.35); color:#d8efff; }
    .badge.green{ border-color: rgba(63,191,127,0.35); color:#d9fff0; }
    .badge.red{ border-color: rgba(204,59,59,0.35); color:#ffd6d6; }

    .log{
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      border-radius: 14px;
      padding:10px 10px;
      color: var(--ink);
      font-size:12px;
      line-height:1.5;
      max-height: 220px;
      overflow:auto;
      white-space:pre-wrap;
    }

    .hint{
      color:var(--muted);
      font-size:12px;
      line-height:1.5;
    }

    /* Map */
    .mapWrap{
      position:relative;
      padding:10px;
    }
    .mapTop{
      padding:14px 16px;
      border-bottom:1px solid var(--stroke);
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:center;
    }
    .mapTop .title{
      display:flex; flex-direction:column; gap:6px;
    }
    .mapTop .title .big{
      margin:0;
      font-size:14px;
      letter-spacing:0.16em;
      text-transform:uppercase;
    }
    .mapTop .title .small{
      color:var(--muted);
      font-size:12px;
      line-height:1.4;
    }
    .mapTools{
      display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;
    }

    svg{
      width:100%;
      height:min(74vh, 860px);
      display:block;
      background: radial-gradient(700px 480px at 40% 30%, rgba(255,255,255,0.06), transparent 60%);
      border-radius: 14px;
      border:1px solid rgba(255,255,255,0.10);
      cursor: grab;
    }
    svg.dragging{ cursor: grabbing; }

    .legend{
      padding:12px 16px;
      border-top:1px solid var(--stroke);
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      color:var(--muted);
      font-size:12px;
    }
    .dot{
      width:10px; height:10px; border-radius:999px; display:inline-block; margin-right:6px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.12);
      transform: translateY(1px);
    }
    .dot.i{ background: rgba(74,166,255,0.25); border-color: rgba(74,166,255,0.45); }
    .dot.x{ background: rgba(63,191,127,0.25); border-color: rgba(63,191,127,0.45); }
    .dot.c{ background: rgba(204,59,59,0.25); border-color: rgba(204,59,59,0.45); }

    .toast{
      position:absolute;
      right:14px;
      bottom:14px;
      padding:10px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.52);
      color: var(--ink);
      font-size:12px;
      line-height:1.4;
      max-width: 520px;
      opacity:0;
      transform: translateY(6px);
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
      box-shadow: var(--shadow);
      white-space:pre-wrap;
    }
    .toast.show{
      opacity:1;
      transform: translateY(0);
    }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>
  <div class="app">
    <!-- LEFT -->
    <div class="panel">
      <div class="p-head">
        <div>
          <h1>Crusade Round Kit</h1>
          <div class="p-sub">
            Strategic rumors: enemy within <span class="mono">4</span> hexes (no LOS). Tactical matchups: enemy within <span class="mono">2</span> hexes + LOS (locks a game).
          </div>
        </div>
        <div class="btnrow">
          <button id="btnNewRound" class="primary" type="button">New Round</button>
          <button id="btnResetMap" class="danger" type="button">Reset Map</button>
        </div>
      </div>

      <div class="p-body">
        <div class="section">
          <h2>Selected Token</h2>
          <div class="kv">
            <div class="pill">
              <div class="k">Faction</div>
              <div class="v" id="selFaction">—</div>
            </div>
            <div class="pill">
              <div class="k">Team</div>
              <div class="v" id="selTeam">—</div>
            </div>
            <div class="pill">
              <div class="k">Hex</div>
              <div class="v mono" id="selHex">—</div>
            </div>
            <div class="pill">
              <div class="k">Status</div>
              <div class="v" id="selStatus">—</div>
            </div>
          </div>

          <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
            <button id="btnRollMove" class="primary" type="button">Roll Move</button>
            <button id="btnClearMove" type="button">Clear Move</button>
          </div>

          <div class="hint" style="margin-top:10px;">
            <div><strong>Move rule:</strong> Roll d3 + team benefit. Then click a destination hex within that many steps (movement respects blocked hexes).</div>
            <div style="margin-top:6px;"><strong>Team benefits:</strong></div>
            <div>• <span class="mono">Imperium</span>: +1 move</div>
            <div>• <span class="mono">Xenos</span>: minimum roll is 2 (a d3 result of 1 becomes 2)</div>
            <div>• <span class="mono">Chaos</span>: +1 effective move if your destination is closer to the nearest enemy than your starting hex</div>
          </div>

          <div class="kv" style="margin-top:10px;">
            <div class="pill">
              <div class="k">Move Points</div>
              <div class="v" id="selMove">—</div>
            </div>
            <div class="pill">
              <div class="k">Destination</div>
              <div class="v mono" id="selDest">—</div>
            </div>
          </div>
        </div>

        <div class="section">
          <h2>Tokens (8)</h2>
          <div class="list" id="tokenList"></div>
        </div>

        <div class="section">
          <h2>Strategic Rumors</h2>
          <div class="log" id="logStrategic"></div>
        </div>

        <div class="section">
          <h2>Tactical Matchups (Locked)</h2>
          <div class="log" id="logTactical"></div>
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="panel">
      <div class="mapTop">
        <div class="title">
          <div class="big">Hex Map</div>
          <div class="small">Mouse wheel: zoom • Click-drag: pan • Click token to select • Roll move, then click destination hex.</div>
        </div>
        <div class="mapTools">
          <button id="btnRegenTerrain" type="button">Randomize Terrain</button>
          <button id="btnCenter" type="button">Center</button>
          <button id="btnExport" type="button">Copy Round Export</button>
        </div>
      </div>

      <div class="mapWrap">
        <svg id="svg" viewBox="0 0 1200 860" aria-label="Hex map"></svg>
        <div class="toast" id="toast"></div>
      </div>

      <div class="legend">
        <span><span class="dot i"></span>Imperium</span>
        <span><span class="dot x"></span>Xenos</span>
        <span><span class="dot c"></span>Chaos</span>
        <span>• Hex label shows terrain + coords • ★ indicates important site</span>
        <span>• <span class="mono">JAM</span> blocks LOS • <span class="mono">X</span> blocks movement</span>
      </div>
    </div>
  </div>

<script>
/* ===========================
   TEAMS + ARMIES (EXACT)
=========================== */
const TEAM = {
  IMPERIUM: "Imperium",
  XENOS: "Xenos",
  CHAOS: "Chaos"
};

// 8 tokens = exactly these 8 armies, assigned to exactly these teams
const TOKEN_ROSTER = [
  // Imperium
  { team: TEAM.IMPERIUM, name: "Grey Knights", short: "GK" },
  { team: TEAM.IMPERIUM, name: "Black Templar", short: "BT" },

  // Xenos
  { team: TEAM.XENOS, name: "Tau", short: "TAU" },
  { team: TEAM.XENOS, name: "Tyranids", short: "NID" },
  { team: TEAM.XENOS, name: "Orks", short: "ORK" },

  // Chaos
  { team: TEAM.CHAOS, name: "Death Guard", short: "DG" },
  { team: TEAM.CHAOS, name: "World Eaters", short: "WE" },
  { team: TEAM.CHAOS, name: "Emperor's Children", short: "EC" }
];

/* ===========================
   MAP: HEX GRID + TERRAIN
=========================== */
const HEX_SIZE = 34;          // px
const GRID_RADIUS = 7;        // wider map (more exploration)
const CENTER = { x: 600, y: 430 };

// Clear, readable terrain set (with short labels)
const BIOMES = [
  { id:"plains",   label:"PLAINS",  abbr:"PL" },
  { id:"forest",   label:"FOREST",  abbr:"FO" },
  { id:"water",    label:"WATER",   abbr:"WA" },
  { id:"ruins",    label:"RUINS",   abbr:"RU" },
  { id:"hive",     label:"HIVE",    abbr:"HV" },
  { id:"ash",      label:"ASH",     abbr:"AS" },
  { id:"badlands", label:"BADLAND", abbr:"BD" }
];

// Operational traits
const SPECIALS = [
  { id:"none",      label:"—",             blocks_los:false, blocks_movement:false, weight: 84 },
  { id:"blackout",  label:"Sensor Blackout",blocks_los:true,  blocks_movement:false, weight: 10 },
  { id:"exclusion", label:"Exclusion Zone", blocks_los:false, blocks_movement:true,  weight: 6  }
];

// Important points (for clearer destinations)
const IMPORTANT_TYPES = [
  { id:"spaceport",     label:"Spaceport",      weight: 18 },
  { id:"manufactorum",  label:"Manufactorum",   weight: 18 },
  { id:"relic_site",    label:"Relic Site",     weight: 18 },
  { id:"vox_relay",     label:"Vox Relay",      weight: 22 },
  { id:"shrine",        label:"Shrine",         weight: 18 },
  { id:"promethium",    label:"Promethium Rig", weight: 12 },
  { id:"data_vault",    label:"Data Vault",     weight: 12 }
];

let hexes = new Map();   // key "q,r" -> {q,r, biome, special, important?}
let tokens = [];
let round = 1;

let selectedTokenId = null;
let plannedDestKey = null;

let strategicRumors = [];     // {id, tokenA, tokenB, text, locationKey}
let tacticalMatchups = [];    // {id, tokenA, tokenB, locationKey, text}
let seenStrategicPairs = new Set();

/* ===========================
   UI helpers
=========================== */
const $ = (id) => document.getElementById(id);
const svg = $("svg");
const svgNS = "http://www.w3.org/2000/svg";

const keyOf = (q,r) => `${q},${r}`;
const parseKey = (k) => {
  const [q,r] = k.split(",").map(Number);
  return {q,r};
};

function toast(msg){
  const el = $("toast");
  el.textContent = msg;
  el.classList.add("show");
  clearTimeout(toast._t);
  toast._t = setTimeout(() => el.classList.remove("show"), 2200);
}

function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function weightedPick(items){
  const total = items.reduce((s,it)=>s+(it.weight||1),0);
  let r = Math.random()*total;
  for(const it of items){
    r -= (it.weight||1);
    if(r<=0) return it;
  }
  return items[items.length-1];
}
const pick = (arr) => arr[Math.floor(Math.random()*arr.length)];

/* ===========================
   HEX MATH (axial q,r)
=========================== */
function axialDistance(aq,ar,bq,br){
  const ax=aq, az=ar, ay=-ax-az;
  const bx=bq, bz=br, by=-bx-bz;
  return Math.max(Math.abs(ax-bx), Math.abs(ay-by), Math.abs(az-bz));
}

function neighborsOf(q,r){
  const dirs = [
    {dq: 1, dr: 0}, {dq: 1, dr:-1}, {dq: 0, dr:-1},
    {dq:-1, dr: 0}, {dq:-1, dr: 1}, {dq: 0, dr: 1}
  ];
  return dirs.map(d => ({q:q+d.dq, r:r+d.dr}));
}

function axialToPixel(q,r){
  const x = HEX_SIZE * (Math.sqrt(3)*q + Math.sqrt(3)/2*r) + CENTER.x;
  const y = HEX_SIZE * (3/2*r) + CENTER.y;
  return {x,y};
}

function hexCorners(q,r){
  const c = axialToPixel(q,r);
  const pts = [];
  for(let i=0;i<6;i++){
    const ang = (Math.PI/180) * (60*i - 30);
    pts.push({
      x: c.x + HEX_SIZE * Math.cos(ang),
      y: c.y + HEX_SIZE * Math.sin(ang)
    });
  }
  return pts;
}

/* Cube line for LOS */
function axialToCube(q,r){ return {x:q, z:r, y:-q-r}; }
function cubeToAxial(c){ return {q:c.x, r:c.z}; }
function cubeLerp(a,b,t){ return { x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t, z:a.z+(b.z-a.z)*t }; }
function cubeRound(x,y,z){
  let rx=Math.round(x), ry=Math.round(y), rz=Math.round(z);
  const dx=Math.abs(rx-x), dy=Math.abs(ry-y), dz=Math.abs(rz-z);
  if(dx>dy && dx>dz) rx=-ry-rz;
  else if(dy>dz) ry=-rx-rz;
  else rz=-rx-ry;
  return {x:rx,y:ry,z:rz};
}
function hexLine(aq,ar,bq,br){
  const a=axialToCube(aq,ar), b=axialToCube(bq,br);
  const N=axialDistance(aq,ar,bq,br);
  const out=[];
  for(let i=0;i<=N;i++){
    const t = (N===0) ? 0 : (i/N);
    const p = cubeLerp(a,b,t);
    const r = cubeRound(p.x,p.y,p.z);
    out.push(cubeToAxial(r));
  }
  return out;
}
function hasLOS(aq,ar,bq,br){
  const line = hexLine(aq,ar,bq,br);
  for(let i=1;i<line.length-1;i++){
    const k = keyOf(line[i].q, line[i].r);
    const h = hexes.get(k);
    if(h?.special?.blocks_los) return false;
  }
  return true;
}

/* ===========================
   PATHFINDING (movement)
=========================== */
function shortestPathLength(fromKey, toKey){
  if(fromKey===toKey) return 0;
  const start = parseKey(fromKey);

  const visited = new Set([fromKey]);
  const queue = [{q:start.q, r:start.r, d:0}];

  while(queue.length){
    const cur = queue.shift();
    for(const nb of neighborsOf(cur.q, cur.r)){
      const nk = keyOf(nb.q, nb.r);
      if(visited.has(nk)) continue;
      const h = hexes.get(nk);
      if(!h) continue;
      if(h.special?.blocks_movement) continue;

      visited.add(nk);
      const nd = cur.d + 1;
      if(nk === toKey) return nd;
      queue.push({q:nb.q, r:nb.r, d:nd});
    }
  }
  return Infinity;
}

/* ===========================
   TERRAIN
=========================== */
function generateHexes(){
  hexes = new Map();
  for(let q=-GRID_RADIUS; q<=GRID_RADIUS; q++){
    for(let r=-GRID_RADIUS; r<=GRID_RADIUS; r++){
      if(axialDistance(0,0,q,r) > GRID_RADIUS) continue;

      const biome = pick(BIOMES);
      const special = weightedPick(SPECIALS);

      hexes.set(keyOf(q,r), { q,r, biome, special, important:null });
    }
  }

  // sprinkle important sites (10–12, since map is bigger)
  const keys = [...hexes.keys()];
  const count = randInt(10,12);
  for(let i=0;i<count;i++){
    const k = keys[randInt(0, keys.length-1)];
    const h = hexes.get(k);
    if(!h || h.special.blocks_movement) { i--; continue; }
    if(h.important) { i--; continue; }

    const it = weightedPick(IMPORTANT_TYPES);
    h.important = { type: it.id, label: it.label, importance: randInt(2,5) };
  }
}

/* ===========================
   TOKENS
=========================== */
function teamColor(team){
  if(team===TEAM.IMPERIUM) return { stroke:"rgba(74,166,255,0.62)", fill:"rgba(74,166,255,0.22)", badge:"blue" };
  if(team===TEAM.XENOS)    return { stroke:"rgba(63,191,127,0.62)", fill:"rgba(63,191,127,0.22)", badge:"green" };
  return { stroke:"rgba(204,59,59,0.62)", fill:"rgba(204,59,59,0.22)", badge:"red" };
}

function placeTokens(){
  tokens = TOKEN_ROSTER.map((t, idx) => ({
    id: `t${idx+1}`,
    team: t.team,
    faction: t.name,
    short: t.short,
    q: 0, r: 0,
    status: "available",
    movePoints: null,
    moveFrom: null
  }));

  // Start regions (3 “corners”)
  const starts = {
    [TEAM.IMPERIUM]: [
      {q:-GRID_RADIUS, r:0}, {q:-GRID_RADIUS+1, r:-1}
    ],
    [TEAM.XENOS]: [
      {q:GRID_RADIUS, r:0}, {q:GRID_RADIUS-1, r:1}, {q:GRID_RADIUS-1, r:0}
    ],
    [TEAM.CHAOS]: [
      {q:0, r:-GRID_RADIUS}, {q:1, r:-GRID_RADIUS+1}, {q:-1, r:-GRID_RADIUS+1}
    ]
  };

  const byTeam = {
    [TEAM.IMPERIUM]: tokens.filter(t=>t.team===TEAM.IMPERIUM),
    [TEAM.XENOS]: tokens.filter(t=>t.team===TEAM.XENOS),
    [TEAM.CHAOS]: tokens.filter(t=>t.team===TEAM.CHAOS)
  };

  for(const team of Object.values(TEAM)){
    const arr = byTeam[team];
    const spots = starts[team] || [];
    arr.forEach((tok, i) => {
      const s = spots[i] || {q:0,r:0};
      let q=s.q, r=s.r;
      for(let tries=0; tries<10; tries++){
        const h = hexes.get(keyOf(q,r));
        if(h && !h.special.blocks_movement) break;
        // nudge inward
        if(team===TEAM.IMPERIUM) q++;
        if(team===TEAM.XENOS) q--;
        if(team===TEAM.CHAOS) r++;
      }
      tok.q=q; tok.r=r;
    });
  }

  selectedTokenId = tokens[0]?.id || null;
}

/* ===========================
   MOVEMENT
=========================== */
function d3(){ return randInt(1,3); }

function nearestEnemyDistance(tokenId, q, r){
  const me = tokens.find(t=>t.id===tokenId);
  if(!me) return Infinity;
  let best = Infinity;
  for(const other of tokens){
    if(other.id===me.id) continue;
    if(other.status !== "available") continue;
    if(other.team === me.team) continue;
    best = Math.min(best, axialDistance(q,r, other.q, other.r));
  }
  return best;
}

function rollMoveFor(token){
  if(!token) return;
  if(token.status !== "available"){
    toast("This token is engaged (already matched).");
    return;
  }
  const roll = d3();
  let move = roll;

  if(token.team === TEAM.IMPERIUM){
    move = roll + 1;
  } else if(token.team === TEAM.XENOS){
    move = Math.max(2, roll);
  } else if(token.team === TEAM.CHAOS){
    move = roll; // +1 conditional at destination check
  }

  token.movePoints = move;
  token.moveFrom = keyOf(token.q, token.r);
  plannedDestKey = null;

  toast(`Move rolled for ${token.faction}: d3=${roll} → Move=${move}`);
}

function chaosEffectiveMove(token, destKey){
  if(token.team !== TEAM.CHAOS) return token.movePoints ?? 0;
  if(token.movePoints == null || !token.moveFrom) return token.movePoints ?? 0;

  const start = parseKey(token.moveFrom);
  const dest = parseKey(destKey);

  const nearestStart = nearestEnemyDistance(token.id, start.q, start.r);
  const nearestDest  = nearestEnemyDistance(token.id, dest.q, dest.r);

  let eff = token.movePoints;
  if(Number.isFinite(nearestStart) && Number.isFinite(nearestDest) && nearestDest < nearestStart){
    eff += 1;
  }
  return eff;
}

/* ===========================
   RUMORS (2 layers)
=========================== */
const STRATEGIC_TEMPLATES = [
  "Long-range augurs register hostile movement near {place}. No visual confirmation. Indicators suggest {theme}.",
  "Vox-traffic distortions cluster around {place}. Reports conflict, but point to {theme}. Treat as pressure.",
  "Civilian rumor chains and intercepted chatter mention {place}. The pattern reads as {theme}. Expect misdirection."
];

const TACTICAL_TEMPLATES = [
  "Forward elements confirm enemy presence near {place}. Visual contact established: {a} vs {b}.",
  "Auspex lock achieved at {place}. Immediate threat confirmed. Matchup authorized: {a} against {b}.",
  "Confirmed sightings at {place}. This is no longer conjecture — {a} will clash with {b}."
];

const THEMES_BY_BIOME = {
  plains:   ["rapid maneuver", "flanking pressure", "breakthrough attempts", "counter-advances"],
  forest:   ["infiltration signs", "missing scouts", "ambush corridors", "concealed approach routes"],
  water:    ["crossing disruption", "isolated detachments", "supply delays", "stranded reinforcements"],
  ruins:    ["close-quarters sweeps", "hidden assets", "civilian unrest", "shadowed kill-zones"],
  hive:     ["crowded kill zones", "data-theft risk", "insurrection whispers", "sealed bulkheads shifting"],
  ash:      ["sensor noise", "toxic exposure", "auspex distortion", "lost bearings"],
  badlands: ["chokepoints", "raider lanes", "false trails", "line-of-advance traps"]
};

function normalizePair(aId,bId){ return [aId,bId].sort().join("|"); }

function bestContextPlace(a, b){
  // Prefer nearest important hex within 2 of either token; else use midpoint biome.
  let best=null, bestScore=-1;

  for(const [k,h] of hexes.entries()){
    if(h.special?.blocks_movement) continue;
    const da = axialDistance(a.q,a.r, h.q,h.r);
    const db = axialDistance(b.q,b.r, h.q,h.r);
    if(Math.min(da,db) > 2) continue;

    let score = 0;
    if(h.important) score += h.important.importance * 10;
    if(h.special?.blocks_los) score += 6;      // blackout is narratively spicy
    score += (2 - Math.min(da,db)) * 2;
    if(score > bestScore){ bestScore=score; best={k,h}; }
  }

  if(best){
    const h = best.h;
    const parts = [];
    if(h.important) parts.push("★ " + h.important.label);
    parts.push(h.biome.label);
    if(h.special?.id === "blackout") parts.push("JAMMED");
    if(h.special?.id === "exclusion") parts.push("EXCLUSION");
    return { place: parts.join(" — "), biomeId: h.biome.id, key: best.k };
  }

  const mq = Math.round((a.q + b.q)/2);
  const mr = Math.round((a.r + b.r)/2);
  const mk = keyOf(mq,mr);
  const mh = hexes.get(mk) || hexes.get(keyOf(a.q,a.r));
  return {
    place: mh ? mh.biome.label : "Unknown Sector",
    biomeId: mh ? mh.biome.id : "plains",
    key: mh ? mk : keyOf(a.q,a.r)
  };
}

function generateStrategicRumor(a, b){
  const ctx = bestContextPlace(a,b);
  const themePool = THEMES_BY_BIOME[ctx.biomeId] || THEMES_BY_BIOME.plains;
  const tpl = pick(STRATEGIC_TEMPLATES);
  return {
    text: tpl.replace("{place}", ctx.place).replace("{theme}", pick(themePool)),
    locationKey: ctx.key
  };
}

function generateTacticalRumor(a, b){
  const ctx = bestContextPlace(a,b);
  const tpl = pick(TACTICAL_TEMPLATES);
  return {
    text: tpl.replace("{place}", ctx.place).replace("{a}", a.faction).replace("{b}", b.faction),
    locationKey: ctx.key
  };
}

function checkRumorsAfterMove(movedToken){
  if(!movedToken || movedToken.status !== "available") return;

  // Tactical first: within 2 + LOS
  const candidatesTac = [];
  for(const other of tokens){
    if(other.id === movedToken.id) continue;
    if(other.status !== "available") continue;
    if(other.team === movedToken.team) continue;
    const d = axialDistance(movedToken.q, movedToken.r, other.q, other.r);
    if(d <= 2 && hasLOS(movedToken.q, movedToken.r, other.q, other.r)){
      candidatesTac.push({ other, d });
    }
  }
  candidatesTac.sort((a,b)=>a.d-b.d);
  if(candidatesTac.length){
    const enemy = candidatesTac[0].other;
    const r = generateTacticalRumor(movedToken, enemy);

    movedToken.status = "engaged";
    enemy.status = "engaged";

    tacticalMatchups.push({
      id: `M-${round}-${tacticalMatchups.length+1}`,
      tokenA: movedToken.id,
      tokenB: enemy.id,
      locationKey: r.locationKey,
      text: r.text,
      createdAt: Date.now()
    });

    toast(`TACTICAL CONTACT: matchup locked → ${movedToken.faction} vs ${enemy.faction}`);
    renderAll();
    return;
  }

  // Strategic: within 4, no LOS
  const candidatesStrat = [];
  for(const other of tokens){
    if(other.id === movedToken.id) continue;
    if(other.status !== "available") continue;
    if(other.team === movedToken.team) continue;

    const d = axialDistance(movedToken.q, movedToken.r, other.q, other.r);
    if(d <= 4){
      const pairKey = normalizePair(movedToken.id, other.id);
      if(seenStrategicPairs.has(pairKey)) continue;
      candidatesStrat.push({ other, d, pairKey });
    }
  }
  candidatesStrat.sort((a,b)=>a.d-b.d);
  if(candidatesStrat.length){
    const c = candidatesStrat[0];
    seenStrategicPairs.add(c.pairKey);

    const r = generateStrategicRumor(movedToken, c.other);
    strategicRumors.push({
      id: `S-${round}-${strategicRumors.length+1}`,
      tokenA: movedToken.id,
      tokenB: c.other.id,
      text: r.text,
      locationKey: r.locationKey,
      createdAt: Date.now()
    });

    toast(`Strategic pressure (≤4): ${movedToken.faction} near ${c.other.faction}`);
    renderAll();
  }
}

/* ===========================
   SVG draw
=========================== */
function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

function biomeStyle(h){
  // stronger stroke + clearer fill differences
  let fill = "rgba(255,255,255,0.05)";
  let stroke = "rgba(255,255,255,0.18)";

  switch(h.biome.id){
    case "forest":   fill="rgba(63,191,127,0.07)"; stroke="rgba(63,191,127,0.24)"; break;
    case "water":    fill="rgba(74,166,255,0.07)"; stroke="rgba(74,166,255,0.24)"; break;
    case "ruins":    fill="rgba(209,161,75,0.07)"; stroke="rgba(209,161,75,0.26)"; break;
    case "hive":     fill="rgba(255,255,255,0.06)"; stroke="rgba(255,255,255,0.26)"; break;
    case "ash":      fill="rgba(204,59,59,0.06)"; stroke="rgba(204,59,59,0.22)"; break;
    case "badlands": fill="rgba(209,161,75,0.05)"; stroke="rgba(209,161,75,0.22)"; break;
    default: break;
  }

  if(h.special?.id === "blackout"){
    stroke = "rgba(204,59,59,0.42)";
    fill = "rgba(0,0,0,0.34)";
  }
  if(h.special?.id === "exclusion"){
    stroke = "rgba(204,59,59,0.50)";
    fill = "rgba(204,59,59,0.09)";
  }
  return {fill, stroke};
}

function drawHexes(){
  for(const [k,h] of hexes.entries()){
    const pts = hexCorners(h.q,h.r).map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
    const st = biomeStyle(h);

    const poly = document.createElementNS(svgNS, "polygon");
    poly.setAttribute("points", pts);
    poly.setAttribute("fill", st.fill);
    poly.setAttribute("stroke", st.stroke);
    poly.setAttribute("stroke-width", "1.6");
    poly.setAttribute("data-hex", k);
    poly.addEventListener("click", (e) => {
      e.stopPropagation();
      onHexClicked(k);
    });
    svg.appendChild(poly);

    // Hex label: "ABBR q,r" (clear identity)
    const c = axialToPixel(h.q,h.r);
    const label = document.createElementNS(svgNS, "text");
    label.setAttribute("x", c.x);
    label.setAttribute("y", c.y + 3);
    label.setAttribute("text-anchor", "middle");
    label.setAttribute("font-size", "9.5");
    label.setAttribute("fill", "rgba(255,255,255,0.70)");
    label.setAttribute("class","mono");
    label.setAttribute("pointer-events","none");
    label.textContent = `${h.biome.abbr} ${h.q},${h.r}`;
    svg.appendChild(label);

    // Important marker
    if(h.important){
      const star = document.createElementNS(svgNS, "text");
      star.setAttribute("x", c.x);
      star.setAttribute("y", c.y - 12);
      star.setAttribute("text-anchor", "middle");
      star.setAttribute("font-size", "12");
      star.setAttribute("fill", "rgba(209,161,75,0.85)");
      star.setAttribute("pointer-events","none");
      star.textContent = "★";
      svg.appendChild(star);
    }

    // Special markers
    if(h.special?.id === "blackout"){
      const t = document.createElementNS(svgNS, "text");
      t.setAttribute("x", c.x);
      t.setAttribute("y", c.y + 18);
      t.setAttribute("text-anchor", "middle");
      t.setAttribute("font-size", "9.5");
      t.setAttribute("fill", "rgba(255,255,255,0.72)");
      t.setAttribute("class","mono");
      t.setAttribute("pointer-events","none");
      t.textContent = "JAM";
      svg.appendChild(t);
    }
    if(h.special?.id === "exclusion"){
      const t = document.createElementNS(svgNS, "text");
      t.setAttribute("x", c.x);
      t.setAttribute("y", c.y + 18);
      t.setAttribute("text-anchor", "middle");
      t.setAttribute("font-size", "10.5");
      t.setAttribute("fill", "rgba(255,255,255,0.78)");
      t.setAttribute("class","mono");
      t.setAttribute("pointer-events","none");
      t.textContent = "X";
      svg.appendChild(t);
    }
  }
}

function drawHighlights(){
  // destination highlight
  if(plannedDestKey){
    const h = hexes.get(plannedDestKey);
    if(h){
      const pts = hexCorners(h.q,h.r).map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
      const poly = document.createElementNS(svgNS, "polygon");
      poly.setAttribute("points", pts);
      poly.setAttribute("fill", "rgba(74,166,255,0.10)");
      poly.setAttribute("stroke", "rgba(74,166,255,0.55)");
      poly.setAttribute("stroke-width", "2.4");
      poly.setAttribute("pointer-events", "none");
      svg.appendChild(poly);
    }
  }

  // selected token hex outline
  const tok = getSelectedToken();
  if(tok){
    const k = keyOf(tok.q,tok.r);
    const h = hexes.get(k);
    if(h){
      const pts = hexCorners(h.q,h.r).map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
      const poly = document.createElementNS(svgNS, "polygon");
      poly.setAttribute("points", pts);
      poly.setAttribute("fill", "transparent");
      poly.setAttribute("stroke", "rgba(255,255,255,0.65)");
      poly.setAttribute("stroke-width", "2.4");
      poly.setAttribute("pointer-events", "none");
      svg.appendChild(poly);
    }
  }
}

function drawTokens(){
  for(const tok of tokens){
    const c = axialToPixel(tok.q, tok.r);
    const g = document.createElementNS(svgNS, "g");
    g.setAttribute("data-token", tok.id);
    g.setAttribute("cursor", "pointer");

    const col = teamColor(tok.team);

    const ring = document.createElementNS(svgNS, "circle");
    ring.setAttribute("cx", c.x);
    ring.setAttribute("cy", c.y);
    ring.setAttribute("r", "16");
    ring.setAttribute("fill", col.fill);
    ring.setAttribute("stroke", col.stroke);
    ring.setAttribute("stroke-width", tok.id===selectedTokenId ? "3.2" : "2.2");
    if(tok.status === "engaged"){
      ring.setAttribute("stroke-dasharray", "3 3");
      ring.setAttribute("fill", "rgba(255,255,255,0.03)");
    }
    g.appendChild(ring);

    const t = document.createElementNS(svgNS, "text");
    t.setAttribute("x", c.x);
    t.setAttribute("y", c.y + 4);
    t.setAttribute("text-anchor", "middle");
    t.setAttribute("font-size", "10.5");
    t.setAttribute("fill", "rgba(255,255,255,0.86)");
    t.setAttribute("class","mono");
    t.textContent = tok.short;
    g.appendChild(t);

    g.addEventListener("click", (e) => {
      e.stopPropagation();
      selectToken(tok.id);
    });

    svg.appendChild(g);
  }
}

function renderMap(){
  clearSVG();
  drawHexes();
  drawTokens();
  drawHighlights();
}

/* ===========================
   Left UI
=========================== */
function getSelectedToken(){
  return tokens.find(t=>t.id===selectedTokenId) || null;
}

function renderTokenList(){
  const list = $("tokenList");
  list.innerHTML = "";
  for(const tok of tokens){
    const card = document.createElement("div");
    card.className = "tokenCard" + (tok.id===selectedTokenId ? " active" : "");
    card.addEventListener("click", ()=>selectToken(tok.id));

    const meta = document.createElement("div");
    meta.className = "tokenMeta";
    const name = document.createElement("div");
    name.className = "tokenName";
    name.textContent = tok.faction;
    const sub = document.createElement("div");
    sub.className = "tokenSub mono";
    sub.textContent = `(${tok.team}) @ ${tok.q},${tok.r} • ${tok.status}`;
    meta.appendChild(name);
    meta.appendChild(sub);

    const badge = document.createElement("div");
    badge.className = "badge " + (teamColor(tok.team).badge || "");
    badge.textContent = tok.short;

    card.appendChild(meta);
    card.appendChild(badge);
    list.appendChild(card);
  }
}

function renderSelected(){
  const tok = getSelectedToken();
  $("selFaction").textContent = tok ? tok.faction : "—";
  $("selTeam").textContent = tok ? tok.team : "—";
  $("selHex").textContent = tok ? `${tok.q},${tok.r}` : "—";
  $("selStatus").textContent = tok ? tok.status : "—";
  $("selMove").textContent = tok && tok.movePoints != null ? String(tok.movePoints) : "—";
  $("selDest").textContent = plannedDestKey || "—";

  $("btnRollMove").disabled = !tok || tok.status!=="available";
  $("btnClearMove").disabled = !tok;
}

function renderLogs(){
  const s = strategicRumors.map(r => {
    const a = tokens.find(t=>t.id===r.tokenA);
    const b = tokens.find(t=>t.id===r.tokenB);
    const loc = hexes.get(r.locationKey);
    const place = loc?.important ? `★ ${loc.important.label}` : (loc?.biome?.label || "Unknown");
    return `• [${r.id}] ${a?.short} ↔ ${b?.short} @ ${place}\n  ${r.text}`;
  }).join("\n\n");

  const t = tacticalMatchups.map(m => {
    const a = tokens.find(t=>t.id===m.tokenA);
    const b = tokens.find(t=>t.id===m.tokenB);
    const loc = hexes.get(m.locationKey);
    const place = loc?.important ? `★ ${loc.important.label}` : (loc?.biome?.label || "Unknown");
    return `• [${m.id}] MATCHUP LOCKED @ ${place}\n  ${a?.faction} vs ${b?.faction}\n  ${m.text}`;
  }).join("\n\n");

  $("logStrategic").textContent = s || "—";
  $("logTactical").textContent = t || "—";
}

function renderAll(){
  renderTokenList();
  renderSelected();
  renderLogs();
  renderMap();
}

/* ===========================
   Interaction
=========================== */
function selectToken(id){
  selectedTokenId = id;
  plannedDestKey = null;
  renderAll();
}

function onHexClicked(hexKey){
  const tok = getSelectedToken();
  if(!tok) return;

  plannedDestKey = hexKey;
  $("selDest").textContent = plannedDestKey;

  if(tok.movePoints == null || !tok.moveFrom){
    toast("Destination selected. Roll movement to execute a move.");
    renderAll();
    return;
  }

  const dist = shortestPathLength(keyOf(tok.q,tok.r), hexKey);
  if(!Number.isFinite(dist) || dist === Infinity){
    toast("No valid path (blocked movement).");
    return;
  }

  const effMove = chaosEffectiveMove(tok, hexKey);
  if(dist > effMove){
    toast(`Too far: path=${dist} > move=${effMove}`);
    return;
  }

  const dest = parseKey(hexKey);
  tok.q = dest.q;
  tok.r = dest.r;

  tok.movePoints = null;
  tok.moveFrom = null;

  checkRumorsAfterMove(tok);
  renderAll();
}

/* ===========================
   Buttons
=========================== */
$("btnRollMove").addEventListener("click", () => {
  const tok = getSelectedToken();
  if(!tok) return;
  rollMoveFor(tok);
  renderAll();
});

$("btnClearMove").addEventListener("click", () => {
  const tok = getSelectedToken();
  if(!tok) return;
  tok.movePoints = null;
  tok.moveFrom = null;
  plannedDestKey = null;
  toast("Move cleared.");
  renderAll();
});

$("btnNewRound").addEventListener("click", () => {
  round += 1;
  strategicRumors = [];
  tacticalMatchups = [];
  seenStrategicPairs = new Set();

  for(const t of tokens){
    t.status = "available";
    t.movePoints = null;
    t.moveFrom = null;
  }
  plannedDestKey = null;
  toast(`New round started: Round ${round}`);
  renderAll();
});

$("btnResetMap").addEventListener("click", () => {
  round = 1;
  strategicRumors = [];
  tacticalMatchups = [];
  seenStrategicPairs = new Set();
  generateHexes();
  placeTokens();
  plannedDestKey = null;

  resetView();
  toast("Map and round state reset.");
  renderAll();
});

$("btnRegenTerrain").addEventListener("click", () => {
  generateHexes();
  // Keep token positions, but if any token is now on a blocked hex, nudge them
  for(const tok of tokens){
    const k = keyOf(tok.q,tok.r);
    const h = hexes.get(k);
    if(h?.special?.blocks_movement){
      const nbs = neighborsOf(tok.q,tok.r);
      let moved=false;
      for(const nb of nbs){
        const nh = hexes.get(keyOf(nb.q,nb.r));
        if(nh && !nh.special.blocks_movement){
          tok.q=nb.q; tok.r=nb.r; moved=true; break;
        }
      }
      if(!moved){ tok.q=0; tok.r=0; }
    }
  }
  toast("Terrain randomized (tokens preserved).");
  renderAll();
});

$("btnCenter").addEventListener("click", () => {
  resetView();
  toast("View centered.");
});

$("btnExport").addEventListener("click", async () => {
  const exportObj = {
    round,
    map: { gridRadius: GRID_RADIUS },
    tokens: tokens.map(t=>({ id:t.id, team:t.team, faction:t.faction, short:t.short, q:t.q, r:t.r, status:t.status })),
    strategicRumors,
    tacticalMatchups
  };
  const text = JSON.stringify(exportObj, null, 2);
  try{
    await navigator.clipboard.writeText(text);
    toast("Round export copied (JSON).");
  }catch(e){
    console.log(text);
    toast("Clipboard blocked — export printed to console.");
  }
});

/* ===========================
   ZOOM + PAN (SVG viewBox)
=========================== */
let vb = { x:0, y:0, w:1200, h:860 };
function applyViewBox(){
  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
}
function resetView(){
  vb = { x:0, y:0, w:1200, h:860 };
  applyViewBox();
}
resetView();

function svgPointFromClient(clientX, clientY){
  const rect = svg.getBoundingClientRect();
  const px = (clientX - rect.left) / rect.width;
  const py = (clientY - rect.top) / rect.height;
  return { x: vb.x + px*vb.w, y: vb.y + py*vb.h };
}

let isDragging = false;
let dragStart = null;
let vbStart = null;

svg.addEventListener("mousedown", (e) => {
  // don’t start panning when clicking on a token/hex click handlers already stopPropagation
  isDragging = true;
  svg.classList.add("dragging");
  dragStart = svgPointFromClient(e.clientX, e.clientY);
  vbStart = { ...vb };
});

window.addEventListener("mousemove", (e) => {
  if(!isDragging) return;
  const cur = svgPointFromClient(e.clientX, e.clientY);
  const dx = cur.x - dragStart.x;
  const dy = cur.y - dragStart.y;
  vb.x = vbStart.x - dx;
  vb.y = vbStart.y - dy;
  applyViewBox();
});

window.addEventListener("mouseup", () => {
  if(!isDragging) return;
  isDragging = false;
  svg.classList.remove("dragging");
});

svg.addEventListener("wheel", (e) => {
  e.preventDefault();

  const zoomIntensity = 0.12;
  const delta = Math.sign(e.deltaY);
  const factor = 1 + (delta * zoomIntensity);

  const mouse = svgPointFromClient(e.clientX, e.clientY);

  // clamp zoom
  const newW = vb.w * factor;
  const newH = vb.h * factor;

  const minW = 420;   // max zoom in
  const maxW = 2400;  // max zoom out

  if(newW < minW || newW > maxW) return;

  // zoom toward cursor
  const rx = (mouse.x - vb.x) / vb.w;
  const ry = (mouse.y - vb.y) / vb.h;

  vb.x = mouse.x - rx * newW;
  vb.y = mouse.y - ry * newH;
  vb.w = newW;
  vb.h = newH;

  applyViewBox();
}, { passive:false });

/* ===========================
   INIT
=========================== */
function init(){
  generateHexes();
  placeTokens();
  renderAll();
  toast("Ready. Zoom/pan the map, then start moving tokens.");
}
init();
</script>
</body>
</html>
