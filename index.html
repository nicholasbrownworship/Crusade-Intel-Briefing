<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Crusade Campaign Kit — Player HUD</title>
  <style>
    :root{
      --bg0:#07080b;
      --bg1:#0b0e14;
      --ink:#e9e6dc;
      --muted:#b7b1a2;
      --dim:#7d776b;

      --gold:#d1a14b;
      --red:#cc3b3b;
      --green:#3fbf7f;
      --blue:#4aa6ff;

      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.09);
      --stroke: rgba(255,255,255,0.14);

      --radius:18px;
      --shadow: 0 18px 50px rgba(0,0,0,0.45);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      color:var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(900px 600px at 20% 10%, rgba(74,166,255,0.14), transparent 55%),
        radial-gradient(800px 500px at 80% 30%, rgba(209,161,75,0.10), transparent 55%),
        radial-gradient(900px 700px at 50% 120%, rgba(63,191,127,0.10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 40%, var(--bg0));
      padding:14px;
    }

    .panel{
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .app{
      width:min(1680px, 100%);
      margin:0 auto;
      display:grid;
      grid-template-columns: 360px 1fr 420px;
      gap:12px;
      align-items:stretch;
    }
    @media (max-width: 1260px){
      .app{ grid-template-columns: 1fr; }
      .mapPanel svg{ height: min(70vh, 920px) !important; }
    }

    .title{
      font-size:12px;
      letter-spacing:0.16em;
      text-transform:uppercase;
      color:var(--muted);
      font-weight:900;
    }
    .bigTitle{
      margin:0;
      font-size:14px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      font-weight:1000;
    }
    .sub{
      color:var(--muted);
      font-size:12px;
      line-height:1.35;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    button{
      appearance:none;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color:var(--ink);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:750;
      letter-spacing:0.02em;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      font-size:12px;
      white-space:nowrap;
    }
    button:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.22);
    }
    button.primary{
      border-color: rgba(209,161,75,0.35);
      background: rgba(209,161,75,0.16);
    }
    button.primary:hover{
      background: rgba(209,161,75,0.22);
      border-color: rgba(209,161,75,0.50);
    }
    button:disabled{
      opacity:0.45;
      cursor:not-allowed;
      transform:none;
    }

    .pad{ padding:12px 12px; }
    .section{ padding:12px 12px; border-top:1px solid rgba(255,255,255,0.10); }
    .section:first-child{ border-top:none; }
    .stack{ display:grid; gap:10px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .box{
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      border-radius: 14px;
      padding:10px 10px;
    }

    /* Player HUD */
    .hudHeader{
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,0.10);
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    label{
      color:var(--muted);
      font-size:11px;
      letter-spacing:0.10em;
      text-transform:uppercase;
      font-weight:800;
      display:block;
      margin-bottom:6px;
    }
    select{
      width:100%;
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.22);
      color: var(--ink);
      font-weight:800;
      outline:none;
    }
    select:focus{
      border-color: rgba(74,166,255,0.45);
      box-shadow: 0 0 0 2px rgba(74,166,255,0.12);
    }
    .moveBig{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
    }
    .moveBig .k{
      color:var(--muted);
      font-size:11px;
      letter-spacing:0.10em;
      text-transform:uppercase;
      font-weight:800;
    }
    .moveBig .v{
      font-size:22px;
      font-weight:1000;
      letter-spacing:0.02em;
    }
    .statusLine{
      color:var(--muted);
      font-size:12px;
      line-height:1.4;
    }
    .hintBar{
      border-top:1px solid rgba(255,255,255,0.10);
      padding:10px 12px;
      color:var(--muted);
      font-size:12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    /* Round Board */
    .boardHeader{
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,0.10);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .chip{
      font-size:11px;
      letter-spacing:0.10em;
      text-transform:uppercase;
      padding:6px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      font-weight:900;
    }
    .chip.blue{ border-color: rgba(74,166,255,0.35); color:#d8efff; }
    .chip.green{ border-color: rgba(63,191,127,0.35); color:#d9fff0; }
    .chip.red{ border-color: rgba(204,59,59,0.35); color:#ffd6d6; }
    .chip.gold{ border-color: rgba(209,161,75,0.40); color:#f2e6cf; }

    .list{
      display:grid;
      gap:10px;
    }
    .item{
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      border-radius: 14px;
      padding:10px 10px;
    }
    .item.clickable{
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .item.clickable:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.22);
    }
    .itemTop{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .itemTitle{
      font-weight:1000;
      font-size:13px;
      line-height:1.25;
    }
    .itemSub{
      margin-top:6px;
      color:var(--muted);
      font-size:12px;
      line-height:1.45;
    }
    .smallDim{
      color:var(--dim);
      font-size:11px;
      margin-top:6px;
    }

    .starIcon{
      width:28px; height:28px;
      border-radius: 10px;
      display:grid;
      place-items:center;
      border:1px solid rgba(209,161,75,0.40);
      background: rgba(209,161,75,0.10);
      color: rgba(209,161,75,0.95);
      font-weight:1000;
      flex:0 0 auto;
    }
    .starRow{
      display:flex;
      gap:10px;
      align-items:flex-start;
    }

    /* Map Panel */
    .mapHeader{
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,0.10);
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:flex-start;
    }
    .mapHeader .left{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width:0;
      flex: 1 1 auto;
    }
    .mapHeader .right{
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-end;
      flex: 0 0 auto;
    }

    .focusCard{
      max-width: 520px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      border-radius: 14px;
      padding:10px 10px;
    }
    .focusTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .focusTitle{
      font-weight:1000;
      font-size:12px;
      letter-spacing:0.10em;
      text-transform:uppercase;
      color: #f2e6cf;
    }
    .focusBody{
      margin-top:6px;
      color:var(--ink);
      font-size:12px;
      line-height:1.45;
    }
    .focusMeta{
      margin-top:6px;
      color:var(--muted);
      font-size:11px;
      line-height:1.4;
    }

    .mapWrap{ position:relative; padding:10px; }
    svg{
      width:100%;
      height:min(80vh, 980px);
      display:block;
      background: radial-gradient(700px 480px at 40% 30%, rgba(255,255,255,0.06), transparent 60%);
      border-radius: 14px;
      border:1px solid rgba(255,255,255,0.10);
      cursor: grab;
    }
    svg.dragging{ cursor: grabbing; }

    .toast{
      position:absolute;
      right:14px;
      bottom:14px;
      padding:10px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.52);
      color: var(--ink);
      font-size:12px;
      line-height:1.4;
      max-width: 640px;
      opacity:0;
      transform: translateY(6px);
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
      box-shadow: var(--shadow);
      white-space:pre-wrap;
    }
    .toast.show{ opacity:1; transform: translateY(0); }

    /* GM Drawer */
    .gmDock{ position:sticky; bottom:12px; margin-top:12px; }
    .gmDrawer{ width:min(1680px, 100%); margin:0 auto; }
    details.gm > summary{
      cursor:pointer;
      user-select:none;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color:var(--muted);
      font-weight:1000;
      letter-spacing:0.14em;
      text-transform:uppercase;
      font-size:11px;
      list-style:none;
    }
    details.gm > summary::-webkit-details-marker{ display:none; }
    .gmBody{
      border-top:1px solid rgba(255,255,255,0.10);
      padding:12px 14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .gmBody .left{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .gmBody .right{ color:var(--muted); font-size:12px; line-height:1.4; }

  </style>
</head>
<body>

  <div class="app">
    <!-- PLAYER HUD -->
    <div class="panel">
      <div class="hudHeader">
        <div class="bigTitle">Player HUD</div>
        <div class="sub">Pick your army token, roll movement, then click a highlighted hex.</div>
      </div>

      <div class="section">
        <div class="stack">
          <div>
            <label for="tokenSelect">Your Token</label>
            <select id="tokenSelect"></select>
            <div class="statusLine" id="tokenStatus">—</div>
          </div>

          <div class="moveBig">
            <div>
              <div class="k">Move Points</div>
              <div class="sub">d3 + team bonus</div>
            </div>
            <div class="v mono" id="movePointsBig">—</div>
          </div>

          <div class="row">
            <button class="primary" id="btnRollMove" type="button">Roll Move</button>
            <button id="btnClearMove" type="button">Clear</button>
            <button id="btnFocus" type="button">Focus Me</button>
          </div>

          <div class="box">
            <div class="title">Movement Rules</div>
            <div class="sub" style="margin-top:6px;">
              <span class="mono">Imperium</span>: +1 move<br/>
              <span class="mono">Xenos</span>: minimum roll is 2<br/>
              <span class="mono">Chaos</span>: +1 effective move if destination is closer to nearest enemy
            </div>
          </div>

          <div class="box">
            <div class="title">What to do now</div>
            <div class="sub" id="playerHint" style="margin-top:6px;">
              Select a token to begin.
            </div>
          </div>
        </div>
      </div>

      <div class="hintBar">
        Tactical matchup locks at <span class="mono">range 2 + LOS</span>.
        Strategic rumor appears at <span class="mono">range 4</span>.
      </div>
    </div>

    <!-- MAP -->
    <div class="panel mapPanel">
      <div class="mapHeader">
        <div class="left">
          <div class="bigTitle">Campaign Map</div>
          <div class="sub">Wheel zoom • Drag pan • Click token to select • Roll move then click highlighted hex</div>
          <div class="focusCard" id="focusCard" style="display:none;">
            <div class="focusTop">
              <div class="focusTitle" id="focusTitle">★ STAR SITE</div>
              <div class="chip gold" id="focusChip">STAR</div>
            </div>
            <div class="focusBody" id="focusBody">—</div>
            <div class="focusMeta mono" id="focusMeta">—</div>
          </div>
        </div>
        <div class="right">
          <div class="row">
            <button id="btnCenter" type="button">Center</button>
          </div>
        </div>
      </div>

      <div class="mapWrap">
        <svg id="svg" viewBox="0 0 1200 860" aria-label="Hex map"></svg>
        <div class="toast" id="toast"></div>
      </div>
    </div>

    <!-- ROUND BOARD -->
    <div class="panel">
      <div class="boardHeader">
        <div>
          <div class="bigTitle">Round Board</div>
          <div class="sub">Click any item to jump to its location on the map.</div>
        </div>
        <div class="chip gold" id="roundChip">Round 1</div>
      </div>

      <div class="section">
        <div class="title">Tactical Matchups</div>
        <div class="sub">Locked games (range 2 + LOS). Tokens are removed from pairing pool.</div>
        <div class="list" id="matchupList" style="margin-top:10px;"></div>
      </div>

      <div class="section">
        <div class="title">Strategic Rumors</div>
        <div class="sub">Pressure signals (range 4). These can be dodged by movement.</div>
        <div class="list" id="rumorList" style="margin-top:10px;"></div>
      </div>

      <div class="section">
        <div class="title">Star Sites Control</div>
        <div class="sub">Click a star site to highlight it and read its bonus.</div>
        <div class="list" id="starList" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>

  <!-- GM CONSOLE -->
  <div class="gmDock">
    <div class="panel gmDrawer">
      <details class="gm" id="gmDetails">
        <summary>
          <span>GM Console</span>
          <span class="sub">Reset • Randomize • Export • Round control</span>
        </summary>
        <div class="gmBody">
          <div class="left">
            <button class="primary" id="btnNewRound" type="button">New Round</button>
            <button id="btnRegenTerrain" type="button">Randomize Terrain</button>
            <button id="btnExport" type="button">Copy Round Export</button>
            <button id="btnResetMap" type="button">Reset Map</button>
          </div>
          <div class="right" id="gmStatus">
            Tip: Keep this closed during play. Players only need HUD + Board + Map.
          </div>
        </div>
      </details>
    </div>
  </div>

<script>
/* ===========================
   TEAMS + ARMIES (EXACT)
=========================== */
const TEAM = {
  IMPERIUM: "Imperium",
  XENOS: "Xenos",
  CHAOS: "Chaos"
};

const TOKEN_ROSTER = [
  { team: TEAM.IMPERIUM, name: "Grey Knights", short: "GK" },
  { team: TEAM.IMPERIUM, name: "Black Templar", short: "BT" },

  { team: TEAM.XENOS, name: "Tau", short: "TAU" },
  { team: TEAM.XENOS, name: "Tyranids", short: "NID" },
  { team: TEAM.XENOS, name: "Orks", short: "ORK" },

  { team: TEAM.CHAOS, name: "Death Guard", short: "DG" },
  { team: TEAM.CHAOS, name: "World Eaters", short: "WE" },
  { team: TEAM.CHAOS, name: "Emperor's Children", short: "EC" }
];

/* ===========================
   MAP SETTINGS
=========================== */
const HEX_SIZE = 34;
const GRID_RADIUS = 7;
const CENTER = { x: 600, y: 430 };

const BIOME_CHIP = {
  plains:   { dot:"rgba(255,255,255,0.55)", text:"rgba(255,255,255,0.80)" },
  forest:   { dot:"rgba(63,191,127,0.72)",  text:"rgba(63,191,127,0.94)"  },
  water:    { dot:"rgba(74,166,255,0.72)",  text:"rgba(74,166,255,0.94)"  },
  ruins:    { dot:"rgba(209,161,75,0.72)",  text:"rgba(209,161,75,0.94)"  },
  hive:     { dot:"rgba(255,255,255,0.70)", text:"rgba(255,255,255,0.92)" },
  ash:      { dot:"rgba(204,59,59,0.70)",   text:"rgba(204,59,59,0.92)"   },
  badlands: { dot:"rgba(209,161,75,0.62)",  text:"rgba(209,161,75,0.88)"  }
};

const BIOMES = [
  { id:"plains",   label:"PLAINS",  abbr:"PL" },
  { id:"forest",   label:"FOREST",  abbr:"FO" },
  { id:"water",    label:"WATER",   abbr:"WA" },
  { id:"ruins",    label:"RUINS",   abbr:"RU" },
  { id:"hive",     label:"HIVE",    abbr:"HV" },
  { id:"ash",      label:"ASH",     abbr:"AS" },
  { id:"badlands", label:"BADLAND", abbr:"BD" }
];

const SPECIALS = [
  { id:"none",      label:"—",              blocks_los:false, blocks_movement:false, weight: 84 },
  { id:"blackout",  label:"Sensor Blackout",blocks_los:true,  blocks_movement:false, weight: 10 },
  { id:"exclusion", label:"Exclusion Zone", blocks_los:false, blocks_movement:true,  weight: 6  }
];

const IMPORTANT_TYPES = [
  { id:"spaceport",     label:"Spaceport",      weight: 18 },
  { id:"manufactorum",  label:"Manufactorum",   weight: 18 },
  { id:"relic_site",    label:"Relic Site",     weight: 18 },
  { id:"vox_relay",     label:"Vox Relay",      weight: 22 },
  { id:"shrine",        label:"Shrine",         weight: 18 },
  { id:"promethium",    label:"Promethium Rig", weight: 12 },
  { id:"data_vault",    label:"Data Vault",     weight: 12 }
];

const IMPORTANT_VALUE = {
  spaceport: [
    { tag:"PORT", value:"Rapid deployment corridor", hook:"Once per round, one Imperium token may +1 move after rolling." },
    { tag:"PORT", value:"Air-superiority staging", hook:"When you win a battle here, gain +1 Strategic Rumor influence next round." }
  ],
  manufactorum: [
    { tag:"MFG", value:"War material & repairs", hook:"Once per round, reroll your d3 movement (take the new result)." },
    { tag:"MFG", value:"Vehicle salvage lines", hook:"If you control this, your team gains +1 supply (campaign-level bonus)." }
  ],
  relic_site: [
    { tag:"RELIC", value:"Archaeotech / sacred asset", hook:"Winner of a battle here may claim a one-time +1 CP (next game)." },
    { tag:"RELIC", value:"Unknown weapon signature", hook:"Control grants a defensive edge: enemies treat you as in cover on this hex." }
  ],
  vox_relay: [
    { tag:"VOX", value:"Command & intel advantage", hook:"Once per round, you may generate one extra Strategic Rumor." },
    { tag:"VOX", value:"Signal dominance", hook:"Enemies within 4 hexes cannot hide: their Strategic Rumors always generate." }
  ],
  shrine: [
    { tag:"SHR", value:"Morale & martyrdom site", hook:"First loss each round for controlling team does not reduce star control (narrative resilience)." },
    { tag:"SHR", value:"Pilgrimage control point", hook:"Once per round, a friendly token may move 1 hex for free toward this site." }
  ],
  promethium: [
    { tag:"FUEL", value:"Fuel & combustion supply", hook:"Once per round, add +1 to movement for one token after rolling." },
    { tag:"FUEL", value:"Strategic resource node", hook:"If contested, both sides generate a Strategic Rumor immediately." }
  ],
  data_vault: [
    { tag:"DATA", value:"Targeting data / hidden records", hook:"Once per round, pick a Tactical matchup and reveal its location to all." },
    { tag:"DATA", value:"Secure archives", hook:"Control grants +1 LOS advantage: treat one blackout hex as transparent this round." }
  ]
};

/* ===========================
   STATE
=========================== */
let hexes = new Map();
let tokens = [];
let round = 1;

let selectedTokenId = null;
let plannedDestKey = null;

let strategicRumors = [];
let tacticalMatchups = [];
let seenStrategicPairs = new Set();

let reachable = new Map();
let starControl = new Map();

/* NEW: focused highlight/info */
let focusedHexKey = null;
let focusPulseUntil = 0;

/* ===========================
   DOM + HELPERS
=========================== */
const $ = (id) => document.getElementById(id);
const svg = $("svg");
const svgNS = "http://www.w3.org/2000/svg";

const keyOf = (q,r) => `${q},${r}`;
const parseKey = (k) => {
  const [q,r] = k.split(",").map(Number);
  return {q,r};
};

function toast(msg){
  const el = $("toast");
  el.textContent = msg;
  el.classList.add("show");
  clearTimeout(toast._t);
  toast._t = setTimeout(() => el.classList.remove("show"), 2400);
}

function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function weightedPick(items){
  const total = items.reduce((s,it)=>s+(it.weight||1),0);
  let r = Math.random()*total;
  for(const it of items){
    r -= (it.weight||1);
    if(r<=0) return it;
  }
  return items[items.length-1];
}
const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

function safeClip(str){
  return (str || "").replace(/[^\w\s\-\(\)\.\,\:\;\/]/g, "");
}

/* ===========================
   HEX MATH
=========================== */
function axialDistance(aq,ar,bq,br){
  const ax=aq, az=ar, ay=-ax-az;
  const bx=bq, bz=br, by=-bx-bz;
  return Math.max(Math.abs(ax-bx), Math.abs(ay-by), Math.abs(az-bz));
}
function neighborsOf(q,r){
  const dirs = [
    {dq: 1, dr: 0}, {dq: 1, dr:-1}, {dq: 0, dr:-1},
    {dq:-1, dr: 0}, {dq:-1, dr: 1}, {dq: 0, dr: 1}
  ];
  return dirs.map(d => ({q:q+d.dq, r:r+d.dr}));
}
function axialToPixel(q,r){
  const x = HEX_SIZE * (Math.sqrt(3)*q + Math.sqrt(3)/2*r) + CENTER.x;
  const y = HEX_SIZE * (3/2*r) + CENTER.y;
  return {x,y};
}
function hexCorners(q,r){
  const c = axialToPixel(q,r);
  const pts = [];
  for(let i=0;i<6;i++){
    const ang = (Math.PI/180) * (60*i - 30);
    pts.push({ x: c.x + HEX_SIZE * Math.cos(ang), y: c.y + HEX_SIZE * Math.sin(ang) });
  }
  return pts;
}

/* LOS */
function axialToCube(q,r){ return {x:q, z:r, y:-q-r}; }
function cubeToAxial(c){ return {q:c.x, r:c.z}; }
function cubeLerp(a,b,t){ return { x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t, z:a.z+(b.z-a.z)*t }; }
function cubeRound(x,y,z){
  let rx=Math.round(x), ry=Math.round(y), rz=Math.round(z);
  const dx=Math.abs(rx-x), dy=Math.abs(ry-y), dz=Math.abs(rz-z);
  if(dx>dy && dx>dz) rx=-ry-rz;
  else if(dy>dz) ry=-rx-rz;
  else rz=-rx-ry;
  return {x:rx,y:ry,z:rz};
}
function hexLine(aq,ar,bq,br){
  const a=axialToCube(aq,ar), b=axialToCube(bq,br);
  const N=axialDistance(aq,ar,bq,br);
  const out=[];
  for(let i=0;i<=N;i++){
    const t = (N===0) ? 0 : (i/N);
    const p = cubeLerp(a,b,t);
    const r = cubeRound(p.x,p.y,p.z);
    out.push(cubeToAxial(r));
  }
  return out;
}
function hasLOS(aq,ar,bq,br){
  const line = hexLine(aq,ar,bq,br);
  for(let i=1;i<line.length-1;i++){
    const k = keyOf(line[i].q, line[i].r);
    if(hexes.get(k)?.special?.blocks_los) return false;
  }
  return true;
}

/* ===========================
   TERRAIN + ★ DATA
=========================== */
function generateHexes(){
  hexes = new Map();
  for(let q=-GRID_RADIUS; q<=GRID_RADIUS; q++){
    for(let r=-GRID_RADIUS; r<=GRID_RADIUS; r++){
      if(axialDistance(0,0,q,r) > GRID_RADIUS) continue;
      const biome = pick(BIOMES);
      const special = weightedPick(SPECIALS);
      hexes.set(keyOf(q,r), { q,r, biome, special, important:null });
    }
  }

  const keys = [...hexes.keys()];
  const count = randInt(10,12);
  for(let i=0;i<count;i++){
    const k = keys[randInt(0, keys.length-1)];
    const h = hexes.get(k);
    if(!h || h.special.blocks_movement) { i--; continue; }
    if(h.important) { i--; continue; }

    const it = weightedPick(IMPORTANT_TYPES);
    const v = pick(IMPORTANT_VALUE[it.id] || [{ tag:"SITE", value:"Strategic leverage", hook:"A site worth bleeding for." }]);

    h.important = {
      type: it.id,
      label: it.label,
      tag: v.tag,
      value: v.value,
      hook: v.hook,
      importance: randInt(2,5)
    };
  }

  starControl = new Map();
}

/* ===========================
   TOKENS
=========================== */
function teamColor(team){
  if(team===TEAM.IMPERIUM) return { stroke:"rgba(74,166,255,0.62)", fill:"rgba(74,166,255,0.22)", chip:"blue" };
  if(team===TEAM.XENOS)    return { stroke:"rgba(63,191,127,0.62)", fill:"rgba(63,191,127,0.22)", chip:"green" };
  return { stroke:"rgba(204,59,59,0.62)", fill:"rgba(204,59,59,0.22)", chip:"red" };
}

function placeTokens(){
  tokens = TOKEN_ROSTER.map((t, idx) => ({
    id: `t${idx+1}`,
    team: t.team,
    faction: t.name,
    short: t.short,
    q: 0, r: 0,
    status: "available",
    movePoints: null,
    moveFrom: null
  }));

  // Three evenly spaced corners: (R,0), (-R,R), (0,-R)
  const starts = {
    [TEAM.IMPERIUM]: [
      { q: -GRID_RADIUS,     r:  GRID_RADIUS },
      { q: -GRID_RADIUS + 1, r:  GRID_RADIUS - 1 }
    ],
    [TEAM.XENOS]: [
      { q:  GRID_RADIUS,     r:  0 },
      { q:  GRID_RADIUS - 1, r:  0 },
      { q:  GRID_RADIUS - 1, r:  1 }
    ],
    [TEAM.CHAOS]: [
      { q:  0,               r: -GRID_RADIUS },
      { q:  1,               r: -GRID_RADIUS + 1 },
      { q:  0,               r: -GRID_RADIUS + 1 }
    ]
  };

  const byTeam = {
    [TEAM.IMPERIUM]: tokens.filter(t=>t.team===TEAM.IMPERIUM),
    [TEAM.XENOS]: tokens.filter(t=>t.team===TEAM.XENOS),
    [TEAM.CHAOS]: tokens.filter(t=>t.team===TEAM.CHAOS)
  };

  for(const team of Object.values(TEAM)){
    const arr = byTeam[team];
    const spots = starts[team] || [];
    arr.forEach((tok, i) => {
      const s = spots[i] || {q:0,r:0};
      let q=s.q, r=s.r;
      for(let tries=0; tries<10; tries++){
        const h = hexes.get(keyOf(q,r));
        if(h && !h.special.blocks_movement) break;
        if(team===TEAM.IMPERIUM){ q++; r--; }
        if(team===TEAM.XENOS){ q--; }
        if(team===TEAM.CHAOS){ r++; }
      }
      tok.q=q; tok.r=r;
    });
  }

  selectedTokenId = tokens[0]?.id || null;
  plannedDestKey = null;
  reachable = new Map();
}

/* ===========================
   MOVEMENT
=========================== */
function d3(){ return randInt(1,3); }
function getSelectedToken(){ return tokens.find(t=>t.id===selectedTokenId) || null; }

function nearestEnemyDistance(tokenId, q, r){
  const me = tokens.find(t=>t.id===tokenId);
  if(!me) return Infinity;
  let best = Infinity;
  for(const other of tokens){
    if(other.id===me.id) continue;
    if(other.status !== "available") continue;
    if(other.team === me.team) continue;
    best = Math.min(best, axialDistance(q,r, other.q, other.r));
  }
  return best;
}

function rollMoveFor(token){
  if(!token) return;
  if(token.status !== "available"){ toast("This token is engaged (already matched)."); return; }

  const roll = d3();
  let move = roll;

  if(token.team === TEAM.IMPERIUM) move = roll + 1;
  else if(token.team === TEAM.XENOS) move = Math.max(2, roll);

  token.movePoints = move;
  token.moveFrom = keyOf(token.q, token.r);
  plannedDestKey = null;

  computeReachableForSelected();
  toast(`Move rolled for ${token.faction}: d3=${roll} → Move=${move}`);
}

function bfsReachable(startKey, maxDist){
  const start = parseKey(startKey);
  const dist = new Map();
  const q = [{ q:start.q, r:start.r }];

  dist.set(startKey, 0);

  while(q.length){
    const cur = q.shift();
    const curKey = keyOf(cur.q, cur.r);
    const curD = dist.get(curKey);

    for(const nb of neighborsOf(cur.q, cur.r)){
      const nk = keyOf(nb.q, nb.r);
      if(dist.has(nk)) continue;

      const h = hexes.get(nk);
      if(!h) continue;
      if(h.special?.blocks_movement) continue;

      const nd = curD + 1;
      if(nd > maxDist) continue;

      dist.set(nk, nd);
      q.push({ q:nb.q, r:nb.r });
    }
  }
  return dist;
}

function chaosEffectiveBonusActive(token, destKey){
  if(token.team !== TEAM.CHAOS) return false;
  if(token.movePoints == null || !token.moveFrom) return false;

  const start = parseKey(token.moveFrom);
  const dest = parseKey(destKey);

  const nearestStart = nearestEnemyDistance(token.id, start.q, start.r);
  const nearestDest  = nearestEnemyDistance(token.id, dest.q, dest.r);

  return Number.isFinite(nearestStart) && Number.isFinite(nearestDest) && nearestDest < nearestStart;
}

function computeReachableForSelected(){
  const tok = getSelectedToken();
  reachable = new Map();

  if(!tok || tok.movePoints == null || !tok.moveFrom) return;

  const startKey = keyOf(tok.q, tok.r);

  const base = bfsReachable(startKey, tok.movePoints);
  for(const [k,d] of base.entries()) reachable.set(k,d);

  if(tok.team === TEAM.CHAOS){
    const bonus = bfsReachable(startKey, tok.movePoints + 1);
    for(const [k,d] of bonus.entries()){
      if(!reachable.has(k)) reachable.set(k,d);
    }
  }
}

/* ===========================
   STAR CONTROL
=========================== */
function computeStarControl(){
  starControl = new Map();
  for(const [k,h] of hexes.entries()){
    if(!h.important) continue;

    const occupants = tokens.filter(t => keyOf(t.q,t.r) === k);
    const teamsHere = [...new Set(occupants.map(o => o.team))];

    let owner = null;
    if(teamsHere.length === 1) owner = teamsHere[0];
    else if(teamsHere.length > 1) owner = "Contested";

    starControl.set(k, { owner, occupants });
  }
}

/* ===========================
   RUMORS
=========================== */
const STRATEGIC_TEMPLATES = [
  "Long-range augurs register hostile movement near {place}. Indicators suggest {theme}.",
  "Vox-traffic distortions cluster around {place}. Reports conflict, but point to {theme}.",
  "Civ rumor chains mention {place}. The pattern reads as {theme}. Expect misdirection."
];

const TACTICAL_TEMPLATES = [
  "Forward elements confirm enemy presence near {place}. Contact: {a} vs {b}.",
  "Auspex lock achieved at {place}. Matchup authorized: {a} against {b}.",
  "Confirmed sightings at {place}. {a} will clash with {b}."
];

const THEMES_BY_BIOME = {
  plains:   ["rapid maneuver", "flanking pressure", "breakthrough attempts", "counter-advances"],
  forest:   ["infiltration signs", "missing scouts", "ambush corridors", "concealed approach routes"],
  water:    ["crossing disruption", "isolated detachments", "supply delays", "stranded reinforcements"],
  ruins:    ["close-quarters sweeps", "hidden assets", "civilian unrest", "shadowed kill-zones"],
  hive:     ["crowded kill zones", "data-theft risk", "insurrection whispers", "sealed bulkheads shifting"],
  ash:      ["sensor noise", "toxic exposure", "auspex distortion", "lost bearings"],
  badlands: ["chokepoints", "raider lanes", "false trails", "line-of-advance traps"]
};

function normalizePair(aId,bId){ return [aId,bId].sort().join("|"); }

function bestContextPlace(a, b){
  let best=null, bestScore=-1;

  for(const [k,h] of hexes.entries()){
    if(h.special?.blocks_movement) continue;
    const da = axialDistance(a.q,a.r, h.q,h.r);
    const db = axialDistance(b.q,b.r, h.q,h.r);
    if(Math.min(da,db) > 2) continue;

    let score = 0;
    if(h.important) score += h.important.importance * 10;
    if(h.special?.blocks_los) score += 6;
    score += (2 - Math.min(da,db)) * 2;
    if(score > bestScore){ bestScore=score; best={k,h}; }
  }

  if(best){
    const h = best.h;
    const parts = [];
    if(h.important) parts.push(`★ ${h.important.label} (${h.important.tag})`);
    parts.push(h.biome.label);
    if(h.special?.id === "blackout") parts.push("JAMMED");
    if(h.special?.id === "exclusion") parts.push("EXCLUSION");
    return { place: parts.join(" — "), biomeId: h.biome.id, key: best.k, site: h.important || null };
  }

  const mk = keyOf(a.q,a.r);
  const mh = hexes.get(mk);
  return { place: mh ? mh.biome.label : "Unknown Sector", biomeId: mh ? mh.biome.id : "plains", key: mk, site: mh?.important || null };
}

function generateStrategicRumor(a, b){
  const ctx = bestContextPlace(a,b);
  const themePool = THEMES_BY_BIOME[ctx.biomeId] || THEMES_BY_BIOME.plains;
  const tpl = pick(STRATEGIC_TEMPLATES);
  const base = tpl.replace("{place}", ctx.place).replace("{theme}", pick(themePool));
  const extra = ctx.site ? ` Value at stake: ${ctx.site.value}.` : "";
  return { text: base + extra, locationKey: ctx.key };
}
function generateTacticalRumor(a, b){
  const ctx = bestContextPlace(a,b);
  const tpl = pick(TACTICAL_TEMPLATES);
  const base = tpl.replace("{place}", ctx.place).replace("{a}", a.faction).replace("{b}", b.faction);
  const extra = ctx.site ? ` Objective: ${ctx.site.value}.` : "";
  return { text: base + extra, locationKey: ctx.key };
}

function checkRumorsAfterMove(movedToken){
  if(!movedToken || movedToken.status !== "available") return;

  const candidatesTac = [];
  for(const other of tokens){
    if(other.id === movedToken.id) continue;
    if(other.status !== "available") continue;
    if(other.team === movedToken.team) continue;

    const d = axialDistance(movedToken.q, movedToken.r, other.q, other.r);
    if(d <= 2 && hasLOS(movedToken.q, movedToken.r, other.q, other.r)) candidatesTac.push({ other, d });
  }
  candidatesTac.sort((a,b)=>a.d-b.d);

  if(candidatesTac.length){
    const enemy = candidatesTac[0].other;
    const r = generateTacticalRumor(movedToken, enemy);

    movedToken.status = "engaged";
    enemy.status = "engaged";

    tacticalMatchups.push({
      id: `M-${round}-${tacticalMatchups.length+1}`,
      aId: movedToken.id,
      bId: enemy.id,
      locationKey: r.locationKey,
      text: r.text
    });

    focusHex(r.locationKey, { reason:`Locked matchup: ${movedToken.short} vs ${enemy.short}`, openInfo:true });
    toast(`TACTICAL CONTACT: ${movedToken.faction} vs ${enemy.faction}`);
    return;
  }

  const candidatesStrat = [];
  for(const other of tokens){
    if(other.id === movedToken.id) continue;
    if(other.status !== "available") continue;
    if(other.team === movedToken.team) continue;

    const d = axialDistance(movedToken.q, movedToken.r, other.q, other.r);
    if(d <= 4){
      const pairKey = normalizePair(movedToken.id, other.id);
      if(seenStrategicPairs.has(pairKey)) continue;
      candidatesStrat.push({ other, d, pairKey });
    }
  }
  candidatesStrat.sort((a,b)=>a.d-b.d);

  if(candidatesStrat.length){
    const c = candidatesStrat[0];
    seenStrategicPairs.add(c.pairKey);
    const r = generateStrategicRumor(movedToken, c.other);

    strategicRumors.push({
      id: `S-${round}-${strategicRumors.length+1}`,
      aId: movedToken.id,
      bId: c.other.id,
      locationKey: r.locationKey,
      text: r.text
    });

    toast(`Strategic pressure: ${movedToken.short} near ${c.other.short}`);
  }
}

/* ===========================
   FOCUS / HIGHLIGHT + INFO
=========================== */
function focusHex(hexKey, opts={}){
  const h = hexes.get(hexKey);
  if(!h) return;

  focusedHexKey = hexKey;
  focusPulseUntil = Date.now() + 2400;

  focusOnHex(hexKey);

  // show info card for star site (or if forced openInfo)
  const openInfo = !!opts.openInfo;

  if(h.important || openInfo){
    const card = $("focusCard");
    card.style.display = "block";

    if(h.important){
      const ctl = starControl.get(hexKey)?.owner ?? null;
      const ownerText = ctl ? (ctl==="Contested" ? "Contested" : ctl) : "Unheld";

      $("focusTitle").textContent = `★ ${h.important.label} — ${h.important.tag}`;
      $("focusChip").textContent = ownerText;
      $("focusChip").className = (ctl==="Contested") ? "chip gold" :
        (ctl===TEAM.IMPERIUM) ? "chip blue" :
        (ctl===TEAM.XENOS) ? "chip green" :
        (ctl===TEAM.CHAOS) ? "chip red" : "chip";

      $("focusBody").textContent = `${h.important.value}. ${h.important.hook}`;
      const extra = [];
      extra.push(`Hex ${hexKey}`);
      extra.push(`${h.biome.label}`);
      if(h.special?.id === "blackout") extra.push("LOS: BLOCKED");
      if(h.special?.id === "exclusion") extra.push("MOVE: BLOCKED");
      $("focusMeta").textContent = extra.join(" • ");
    }else{
      $("focusTitle").textContent = `Map Focus`;
      $("focusChip").textContent = "INFO";
      $("focusChip").className = "chip";
      $("focusBody").textContent = opts.reason ? opts.reason : "Focused location.";
      $("focusMeta").textContent = `Hex ${hexKey}`;
    }
  }

  renderAll();
}

/* ===========================
   DRAW
=========================== */
function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

function biomeStyle(h){
  let fill = "rgba(255,255,255,0.05)";
  let stroke = "rgba(255,255,255,0.18)";

  switch(h.biome.id){
    case "forest":   fill="rgba(63,191,127,0.07)"; stroke="rgba(63,191,127,0.24)"; break;
    case "water":    fill="rgba(74,166,255,0.07)"; stroke="rgba(74,166,255,0.24)"; break;
    case "ruins":    fill="rgba(209,161,75,0.07)"; stroke="rgba(209,161,75,0.26)"; break;
    case "hive":     fill="rgba(255,255,255,0.06)"; stroke="rgba(255,255,255,0.26)"; break;
    case "ash":      fill="rgba(204,59,59,0.06)"; stroke="rgba(204,59,59,0.22)"; break;
    case "badlands": fill="rgba(209,161,75,0.05)"; stroke="rgba(209,161,75,0.22)"; break;
  }

  if(h.special?.id === "blackout"){ stroke="rgba(204,59,59,0.42)"; fill="rgba(0,0,0,0.34)"; }
  if(h.special?.id === "exclusion"){ stroke="rgba(204,59,59,0.50)"; fill="rgba(204,59,59,0.09)"; }

  return {fill, stroke};
}

function drawReachableOverlay(){
  if(!reachable || reachable.size === 0) return;
  const tok = getSelectedToken();
  if(!tok || tok.movePoints == null) return;

  const startKey = keyOf(tok.q,tok.r);

  for(const [k,d] of reachable.entries()){
    if(k === startKey) continue;
    const h = hexes.get(k);
    if(!h) continue;

    const pts = hexCorners(h.q,h.r).map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
    const poly = document.createElementNS(svgNS, "polygon");
    poly.setAttribute("points", pts);

    const chaosTint = (tok.team===TEAM.CHAOS && d > tok.movePoints);
    poly.setAttribute("fill", chaosTint ? "rgba(209,161,75,0.10)" : "rgba(74,166,255,0.08)");
    poly.setAttribute("stroke", chaosTint ? "rgba(209,161,75,0.36)" : "rgba(74,166,255,0.34)");
    poly.setAttribute("stroke-width", "2.0");
    poly.setAttribute("pointer-events", "none");

    svg.appendChild(poly);
  }
}

function drawHexes(){
  computeStarControl();

  for(const [k,h] of hexes.entries()){
    const pts = hexCorners(h.q,h.r).map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
    const st = biomeStyle(h);

    const poly = document.createElementNS(svgNS, "polygon");
    poly.setAttribute("points", pts);
    poly.setAttribute("fill", st.fill);
    poly.setAttribute("stroke", st.stroke);
    poly.setAttribute("stroke-width", "1.6");
    poly.setAttribute("data-hex", k);

    poly.addEventListener("click", (e) => { e.stopPropagation(); onHexClicked(k); });

    svg.appendChild(poly);

    const c = axialToPixel(h.q,h.r);

    // Terrain chip
    const chipStyle = BIOME_CHIP[h.biome.id] || BIOME_CHIP.plains;
    const chipX = c.x - 26;
    const chipY = c.y - 26;

    const chipBg = document.createElementNS(svgNS, "rect");
    chipBg.setAttribute("x", chipX);
    chipBg.setAttribute("y", chipY);
    chipBg.setAttribute("width", 50);
    chipBg.setAttribute("height", 16);
    chipBg.setAttribute("rx", 8);
    chipBg.setAttribute("fill", "rgba(0,0,0,0.34)");
    chipBg.setAttribute("stroke", "rgba(255,255,255,0.12)");
    chipBg.setAttribute("stroke-width", "1");
    chipBg.setAttribute("pointer-events", "none");
    svg.appendChild(chipBg);

    const dot = document.createElementNS(svgNS, "circle");
    dot.setAttribute("cx", chipX + 9);
    dot.setAttribute("cy", chipY + 8);
    dot.setAttribute("r", 3.2);
    dot.setAttribute("fill", chipStyle.dot);
    dot.setAttribute("pointer-events", "none");
    svg.appendChild(dot);

    const chipText = document.createElementNS(svgNS, "text");
    chipText.setAttribute("x", chipX + 16);
    chipText.setAttribute("y", chipY + 11.2);
    chipText.setAttribute("font-size", "9.5");
    chipText.setAttribute("fill", chipStyle.text);
    chipText.setAttribute("class", "mono");
    chipText.setAttribute("pointer-events", "none");
    chipText.textContent = h.biome.abbr;
    svg.appendChild(chipText);

    // Special markers
    if(h.special?.id === "blackout"){
      const t = document.createElementNS(svgNS, "text");
      t.setAttribute("x", c.x + 22);
      t.setAttribute("y", c.y + 12);
      t.setAttribute("text-anchor", "middle");
      t.setAttribute("font-size", "9.5");
      t.setAttribute("fill", "rgba(255,255,255,0.72)");
      t.setAttribute("class","mono");
      t.setAttribute("pointer-events","none");
      t.textContent = "JAM";
      svg.appendChild(t);
    }
    if(h.special?.id === "exclusion"){
      const t = document.createElementNS(svgNS, "text");
      t.setAttribute("x", c.x + 22);
      t.setAttribute("y", c.y + 12);
      t.setAttribute("text-anchor", "middle");
      t.setAttribute("font-size", "10.5");
      t.setAttribute("fill", "rgba(255,255,255,0.78)");
      t.setAttribute("class","mono");
      t.setAttribute("pointer-events","none");
      t.textContent = "X";
      svg.appendChild(t);
    }

    // ★ + control ring
    if(h.important){
      const star = document.createElementNS(svgNS, "text");
      star.setAttribute("x", c.x);
      star.setAttribute("y", c.y - 12);
      star.setAttribute("text-anchor", "middle");
      star.setAttribute("font-size", "12");
      star.setAttribute("fill", "rgba(209,161,75,0.90)");
      star.setAttribute("pointer-events","none");
      star.textContent = "★";
      svg.appendChild(star);

      const tag = document.createElementNS(svgNS, "text");
      tag.setAttribute("x", c.x);
      tag.setAttribute("y", c.y - 2);
      tag.setAttribute("text-anchor", "middle");
      tag.setAttribute("font-size", "9.5");
      tag.setAttribute("fill", "rgba(209,161,75,0.85)");
      tag.setAttribute("class", "mono");
      tag.setAttribute("pointer-events","none");
      tag.textContent = h.important.tag;
      svg.appendChild(tag);

      const ctl = starControl.get(k)?.owner ?? null;
      if(ctl){
        const ring = document.createElementNS(svgNS, "circle");
        ring.setAttribute("cx", c.x);
        ring.setAttribute("cy", c.y);
        ring.setAttribute("r", "22");
        if(ctl === "Contested"){
          ring.setAttribute("stroke", "rgba(209,161,75,0.55)");
          ring.setAttribute("stroke-dasharray", "4 3");
        }else{
          const col = teamColor(ctl);
          ring.setAttribute("stroke", col.stroke);
        }
        ring.setAttribute("fill", "transparent");
        ring.setAttribute("stroke-width", "2.0");
        ring.setAttribute("pointer-events","none");
        svg.appendChild(ring);
      }
    }
  }
}

function drawTokens(){
  for(const tok of tokens){
    const c = axialToPixel(tok.q, tok.r);
    const g = document.createElementNS(svgNS, "g");
    g.setAttribute("data-token", tok.id);
    g.setAttribute("cursor", "pointer");

    const col = teamColor(tok.team);

    const ring = document.createElementNS(svgNS, "circle");
    ring.setAttribute("cx", c.x);
    ring.setAttribute("cy", c.y);
    ring.setAttribute("r", "16");
    ring.setAttribute("fill", col.fill);
    ring.setAttribute("stroke", col.stroke);
    ring.setAttribute("stroke-width", tok.id===selectedTokenId ? "3.2" : "2.2");
    if(tok.status === "engaged"){
      ring.setAttribute("stroke-dasharray", "3 3");
      ring.setAttribute("fill", "rgba(255,255,255,0.03)");
    }
    g.appendChild(ring);

    const t = document.createElementNS(svgNS, "text");
    t.setAttribute("x", c.x);
    t.setAttribute("y", c.y + 4);
    t.setAttribute("text-anchor", "middle");
    t.setAttribute("font-size", "10.5");
    t.setAttribute("fill", "rgba(255,255,255,0.86)");
    t.setAttribute("class","mono");
    t.textContent = tok.short;
    g.appendChild(t);

    g.addEventListener("click", (e) => { e.stopPropagation(); selectToken(tok.id); });
    svg.appendChild(g);
  }
}

function drawSelection(){
  const tok = getSelectedToken();
  if(tok){
    const k = keyOf(tok.q,tok.r);
    const h = hexes.get(k);
    if(h){
      const pts = hexCorners(h.q,h.r).map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
      const poly = document.createElementNS(svgNS, "polygon");
      poly.setAttribute("points", pts);
      poly.setAttribute("fill", "transparent");
      poly.setAttribute("stroke", "rgba(255,255,255,0.65)");
      poly.setAttribute("stroke-width", "2.4");
      poly.setAttribute("pointer-events", "none");
      svg.appendChild(poly);
    }
  }

  if(plannedDestKey){
    const d = hexes.get(plannedDestKey);
    if(d){
      const pts = hexCorners(d.q,d.r).map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
      const poly = document.createElementNS(svgNS, "polygon");
      poly.setAttribute("points", pts);
      poly.setAttribute("fill", "rgba(74,166,255,0.10)");
      poly.setAttribute("stroke", "rgba(74,166,255,0.55)");
      poly.setAttribute("stroke-width", "2.6");
      poly.setAttribute("pointer-events", "none");
      svg.appendChild(poly);
    }
  }

  // NEW: focused hex ring + pulse
  if(focusedHexKey){
    const h = hexes.get(focusedHexKey);
    if(h){
      const pts = hexCorners(h.q,h.r);
      const c = axialToPixel(h.q,h.r);

      const poly = document.createElementNS(svgNS, "polygon");
      poly.setAttribute("points", pts.map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" "));
      poly.setAttribute("fill", "rgba(209,161,75,0.08)");
      poly.setAttribute("stroke", "rgba(209,161,75,0.92)");
      poly.setAttribute("stroke-width", "3.0");
      poly.setAttribute("pointer-events", "none");
      svg.appendChild(poly);

      const now = Date.now();
      if(now < focusPulseUntil){
        const pulse = document.createElementNS(svgNS, "circle");
        pulse.setAttribute("cx", c.x);
        pulse.setAttribute("cy", c.y);
        pulse.setAttribute("r", "6");
        pulse.setAttribute("fill", "rgba(209,161,75,0.55)");
        pulse.setAttribute("pointer-events", "none");
        svg.appendChild(pulse);

        // crude pulse animation via RAF: redraw
        requestAnimationFrame(() => renderAll());
      }
    }
  }
}

function renderMap(){
  clearSVG();
  drawHexes();
  drawReachableOverlay();
  drawTokens();
  drawSelection();
}

/* ===========================
   PLAYER HUD RENDER
=========================== */
function renderTokenSelect(){
  const sel = $("tokenSelect");
  sel.innerHTML = "";

  for(const tok of tokens){
    const opt = document.createElement("option");
    opt.value = tok.id;
    opt.textContent = `${tok.faction} (${tok.team}) — ${tok.short}`;
    sel.appendChild(opt);
  }
  sel.value = selectedTokenId || tokens[0]?.id || "";
}

function renderPlayerHUD(){
  const tok = getSelectedToken();
  if(!tok){
    $("tokenStatus").textContent = "—";
    $("movePointsBig").textContent = "—";
    $("playerHint").textContent = "Select a token to begin.";
    $("btnRollMove").disabled = true;
    $("btnClearMove").disabled = true;
    return;
  }

  const onHex = keyOf(tok.q,tok.r);
  const engaged = tok.status !== "available";

  $("tokenStatus").textContent =
    `${tok.team} • ${tok.short} @ ${onHex} • ` + (engaged ? "ENGAGED (matched)" : "READY");

  $("movePointsBig").textContent = (tok.movePoints == null ? "—" : String(tok.movePoints));

  if(engaged){
    $("playerHint").textContent = "This token is engaged this round. Watch Round Board for matchups.";
  }else if(tok.movePoints == null){
    $("playerHint").textContent = "Roll movement, then click any highlighted hex to move.";
  }else{
    if(tok.team === TEAM.CHAOS){
      $("playerHint").textContent = "Click a highlighted hex. Gold reach is conditional (+1 only if you move closer to nearest enemy).";
    }else{
      $("playerHint").textContent = "Click a highlighted hex to move. Tactical contact locks at range 2 + LOS.";
    }
  }

  $("btnRollMove").disabled = engaged;
  $("btnClearMove").disabled = false;
}

/* ===========================
   ROUND BOARD RENDER
=========================== */
function renderMatchups(){
  const el = $("matchupList");
  el.innerHTML = "";

  if(!tacticalMatchups.length){
    const empty = document.createElement("div");
    empty.className = "box";
    empty.innerHTML = `<div class="sub">No locked games yet.</div>`;
    el.appendChild(empty);
    return;
  }

  for(const m of tacticalMatchups){
    const a = tokens.find(t=>t.id===m.aId);
    const b = tokens.find(t=>t.id===m.bId);
    const loc = hexes.get(m.locationKey);
    const place = loc?.important ? `★ ${loc.important.label} (${loc.important.tag})` : (loc?.biome?.label || "Unknown");

    const card = document.createElement("div");
    card.className = "item clickable";
    card.title = "Click to focus this location on the map";
    card.addEventListener("click", () => focusHex(m.locationKey, { reason:m.text, openInfo:true }));

    card.innerHTML = `
      <div class="itemTop">
        <div class="itemTitle">${a?.faction || "?"} vs ${b?.faction || "?"}</div>
        <div class="chip gold">${m.id}</div>
      </div>
      <div class="itemSub">${m.text}</div>
      <div class="smallDim mono">Location: ${place} • Hex ${m.locationKey}</div>
    `;
    el.appendChild(card);
  }
}

function renderRumors(){
  const el = $("rumorList");
  el.innerHTML = "";

  if(!strategicRumors.length){
    const empty = document.createElement("div");
    empty.className = "box";
    empty.innerHTML = `<div class="sub">No strategic pressure signals yet.</div>`;
    el.appendChild(empty);
    return;
  }

  for(const r of strategicRumors.slice(-6).reverse()){
    const a = tokens.find(t=>t.id===r.aId);
    const b = tokens.find(t=>t.id===r.bId);
    const loc = hexes.get(r.locationKey);
    const place = loc?.important ? `★ ${loc.important.label} (${loc.important.tag})` : (loc?.biome?.label || "Unknown");

    const card = document.createElement("div");
    card.className = "item clickable";
    card.title = "Click to focus this location on the map";
    card.addEventListener("click", () => focusHex(r.locationKey, { reason:r.text, openInfo:true }));

    card.innerHTML = `
      <div class="itemTop">
        <div class="itemTitle">${a?.short || "?"} ↔ ${b?.short || "?"}</div>
        <div class="chip">${r.id}</div>
      </div>
      <div class="itemSub">${r.text}</div>
      <div class="smallDim mono">Near: ${place} • Hex ${r.locationKey}</div>
    `;
    el.appendChild(card);
  }
}

function renderStars(){
  computeStarControl();
  const el = $("starList");
  el.innerHTML = "";

  const stars = [...hexes.entries()]
    .filter(([k,h]) => h.important)
    .map(([k,h]) => ({ key:k, hex:h, ctl: starControl.get(k) }))
    .sort((a,b) => (b.hex.important.importance||0) - (a.hex.important.importance||0));

  if(!stars.length){
    const empty = document.createElement("div");
    empty.className = "box";
    empty.innerHTML = `<div class="sub">No star sites found (reroll terrain).</div>`;
    el.appendChild(empty);
    return;
  }

  for(const s of stars){
    const owner = s.ctl?.owner ?? null;

    let chipClass = "chip";
    let chipText = "Unheld";
    if(owner === "Contested"){ chipClass = "chip gold"; chipText="Contested"; }
    else if(owner === TEAM.IMPERIUM){ chipClass="chip blue"; chipText="Imperium"; }
    else if(owner === TEAM.XENOS){ chipClass="chip green"; chipText="Xenos"; }
    else if(owner === TEAM.CHAOS){ chipClass="chip red"; chipText="Chaos"; }

    const occ = (s.ctl?.occupants || []).map(o => o.short).join(", ");

    const card = document.createElement("div");
    card.className = "item clickable";
    card.title = "Click to jump to this star site";
    card.addEventListener("click", () => focusHex(s.key, { openInfo:true }));

    card.innerHTML = `
      <div class="starRow">
        <div class="starIcon">★</div>
        <div style="flex:1 1 auto; min-width:0;">
          <div class="itemTop">
            <div class="itemTitle">${s.hex.important.label} <span class="mono">(${s.hex.important.tag})</span></div>
            <div class="${chipClass}">${chipText}</div>
          </div>
          <div class="itemSub">${s.hex.important.value} — ${s.hex.important.hook}</div>
          <div class="smallDim mono">Hex ${s.key} • Occupants: ${occ || "—"}</div>
        </div>
      </div>
    `;
    el.appendChild(card);
  }
}

function renderRoundChip(){
  $("roundChip").textContent = `Round ${round}`;
}

/* ===========================
   CORE INTERACTION
=========================== */
function selectToken(id){
  selectedTokenId = id;
  plannedDestKey = null;
  computeReachableForSelected();
  renderAll();
}

function onHexClicked(hexKey){
  const tok = getSelectedToken();
  if(!tok) return;

  plannedDestKey = hexKey;

  if(tok.status !== "available"){
    toast("This token is engaged this round.");
    renderAll();
    return;
  }

  if(tok.movePoints == null || !tok.moveFrom){
    // If they click an important hex, focus info anyway
    const h = hexes.get(hexKey);
    if(h?.important) focusHex(hexKey, { openInfo:true });
    else toast("Roll movement first, then click a highlighted hex.");
    renderAll();
    return;
  }

  if(!reachable.has(hexKey)){
    // If it’s a star site, let click be “inspect”
    const h = hexes.get(hexKey);
    if(h?.important) focusHex(hexKey, { openInfo:true });
    else toast("Not reachable (must be highlighted).");
    renderAll();
    return;
  }

  const dist = reachable.get(hexKey);
  if(tok.team === TEAM.CHAOS && dist > tok.movePoints){
    if(!chaosEffectiveBonusActive(tok, hexKey)){
      toast("Chaos +1 not active (destination must be closer to nearest enemy). Pick another hex.");
      renderAll();
      return;
    }
  }

  const dest = parseKey(hexKey);
  tok.q = dest.q;
  tok.r = dest.r;

  tok.movePoints = null;
  tok.moveFrom = null;
  reachable = new Map();
  plannedDestKey = null;

  // If they moved onto a star, auto-focus it
  const h = hexes.get(hexKey);
  if(h?.important) focusHex(hexKey, { openInfo:true });

  checkRumorsAfterMove(tok);
  renderAll();
}

/* ===========================
   BUTTONS
=========================== */
$("tokenSelect").addEventListener("change", (e) => selectToken(e.target.value));

$("btnRollMove").addEventListener("click", () => {
  const tok = getSelectedToken();
  if(!tok) return;
  rollMoveFor(tok);
  renderAll();
});

$("btnClearMove").addEventListener("click", () => {
  const tok = getSelectedToken();
  if(!tok) return;
  tok.movePoints = null;
  tok.moveFrom = null;
  reachable = new Map();
  plannedDestKey = null;
  toast("Move cleared.");
  renderAll();
});

$("btnFocus").addEventListener("click", () => {
  const tok = getSelectedToken();
  if(!tok) return;
  focusOnHex(keyOf(tok.q,tok.r));
  toast("Focused on your token.");
});

$("btnCenter").addEventListener("click", () => {
  resetView();
  toast("View centered.");
});

$("btnNewRound").addEventListener("click", () => {
  round += 1;
  strategicRumors = [];
  tacticalMatchups = [];
  seenStrategicPairs = new Set();

  for(const t of tokens){
    t.status = "available";
    t.movePoints = null;
    t.moveFrom = null;
  }
  reachable = new Map();
  plannedDestKey = null;

  toast(`New round started: Round ${round}`);
  renderAll();
});

$("btnRegenTerrain").addEventListener("click", () => {
  generateHexes();

  for(const tok of tokens){
    const h = hexes.get(keyOf(tok.q,tok.r));
    if(h?.special?.blocks_movement){
      const nbs = neighborsOf(tok.q,tok.r);
      let moved=false;
      for(const nb of nbs){
        const nh = hexes.get(keyOf(nb.q,nb.r));
        if(nh && !nh.special.blocks_movement){
          tok.q=nb.q; tok.r=nb.r; moved=true; break;
        }
      }
      if(!moved){ tok.q=0; tok.r=0; }
    }
  }

  computeReachableForSelected();
  toast("Terrain randomized (tokens preserved).");
  renderAll();
});

$("btnResetMap").addEventListener("click", () => {
  round = 1;
  strategicRumors = [];
  tacticalMatchups = [];
  seenStrategicPairs = new Set();

  generateHexes();
  placeTokens();

  resetView();
  toast("Map and round state reset.");
  renderAll();
});

$("btnExport").addEventListener("click", async () => {
  computeStarControl();
  const exportObj = {
    round,
    map: { gridRadius: GRID_RADIUS },
    tokens: tokens.map(t=>({ id:t.id, team:t.team, faction:t.faction, short:t.short, q:t.q, r:t.r, status:t.status })),
    starControl: [...starControl.entries()].map(([k,v]) => ({ key:k, owner:v.owner, occupants:(v.occupants||[]).map(o=>o.short) })),
    strategicRumors,
    tacticalMatchups
  };
  const text = JSON.stringify(exportObj, null, 2);
  try{
    await navigator.clipboard.writeText(text);
    toast("Round export copied (JSON).");
  }catch(e){
    console.log(text);
    toast("Clipboard blocked — export printed to console.");
  }
});

/* ===========================
   VIEWBOX ZOOM + PAN
=========================== */
let vb = { x:0, y:0, w:1200, h:860 };
function applyViewBox(){ svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.w} ${vb.h}`); }
function resetView(){ vb = { x:0, y:0, w:1200, h:860 }; applyViewBox(); }

function svgPointFromClient(clientX, clientY){
  const rect = svg.getBoundingClientRect();
  const px = (clientX - rect.left) / rect.width;
  const py = (clientY - rect.top) / rect.height;
  return { x: vb.x + px*vb.w, y: vb.y + py*vb.h };
}

let isDragging=false, dragStart=null, vbStart=null;

svg.addEventListener("mousedown", (e) => {
  isDragging = true;
  svg.classList.add("dragging");
  dragStart = svgPointFromClient(e.clientX, e.clientY);
  vbStart = { ...vb };
});
window.addEventListener("mousemove", (e) => {
  if(!isDragging) return;
  const cur = svgPointFromClient(e.clientX, e.clientY);
  const dx = cur.x - dragStart.x;
  const dy = cur.y - dragStart.y;
  vb.x = vbStart.x - dx;
  vb.y = vbStart.y - dy;
  applyViewBox();
});
window.addEventListener("mouseup", () => {
  if(!isDragging) return;
  isDragging = false;
  svg.classList.remove("dragging");
});
svg.addEventListener("wheel", (e) => {
  e.preventDefault();

  const zoomIntensity = 0.12;
  const delta = Math.sign(e.deltaY);
  const factor = 1 + (delta * zoomIntensity);

  const mouse = svgPointFromClient(e.clientX, e.clientY);

  const newW = vb.w * factor;
  const newH = vb.h * factor;

  const minW = 420;
  const maxW = 2400;
  if(newW < minW || newW > maxW) return;

  const rx = (mouse.x - vb.x) / vb.w;
  const ry = (mouse.y - vb.y) / vb.h;

  vb.x = mouse.x - rx * newW;
  vb.y = mouse.y - ry * newH;
  vb.w = newW;
  vb.h = newH;

  applyViewBox();
}, { passive:false });

function focusOnHex(hexKey){
  const h = hexes.get(hexKey);
  if(!h) return;
  const c = axialToPixel(h.q,h.r);
  vb.x = c.x - vb.w/2;
  vb.y = c.y - vb.h/2;
  applyViewBox();
}

/* ===========================
   INIT
=========================== */
function renderAll(){
  renderRoundChip();
  renderTokenSelect();
  renderPlayerHUD();
  renderMatchups();
  renderRumors();
  renderStars();
  renderMap();
}

function init(){
  generateHexes();
  placeTokens();
  resetView();
  computeReachableForSelected();
  renderAll();
  toast("Click a ★ site on the right to jump to it and see its bonus.");
}
init();
</script>
</body>
</html>
